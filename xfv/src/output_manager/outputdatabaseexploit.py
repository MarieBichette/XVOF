"""
A module allowing exploitation of the Hdf5 output database
"""

import sys
from bisect import bisect
import h5py
import numpy as np
from xfv.src.output_manager.truefieldsbuilder import build_cell_true_field, build_node_true_field


class OutputDatabaseExploit:
    """
    A class for exploiting the output stored in Hdf5 database
    """
    field_type_converter = dict()
    field_type_converter["Pressure"] = ("ClassicalPressure", "AdditionalPressure")
    field_type_converter["Stress"] = ("ClassicalStress", "AdditionalStress")
    field_type_converter["PlasticStrainRate"] = ("ClassicalPlasticStrainRate",
                                                 "AdditionalPlasticStrainRate")
    field_type_converter["Density"] = ("ClassicalDensity", "AdditionalDensity")
    field_type_converter["InternalEnergy"] = ("ClassicalInternalEnergy", "AdditionalInternalEnergy")
    field_type_converter["SoundVelocity"] = ("ClassicalSoundVelocity", "AdditionalSoundVelocity")
    field_type_converter["ArtificialViscosity"] = ("ClassicalArtificialViscosity",
                                                   "AdditionalArtificialViscosity")
    field_type_converter["DeviatoricStress"] = ("ClassicalDeviatoricStress",
                                                "AdditionalDeviatoricStress")
    field_type_converter["EquivalentPlasticStrainRate"] = \
        ("ClassicalEquivalentPlasticStrainRate", "AdditionalEquivalentPlasticStrainRate")
    field_type_converter["NodeVelocity"] = ("ClassicalNodeVelocity", "AdditionalNodeVelocity")
    field_type_converter["NodeCoordinates"] = ("NodeCoordinates", "None")
    field_type_converter["CohesiveForce"] = ("AdditionalCohesiveForce", "None")
    field_type_converter["Porosity"] = ("ClassicalPorosity", "None")
    field_type_converter["ShearModulus"] = ("ClassicalShearModulus", "None")
    field_type_converter["YieldStress"] = ("ClassicalYieldStress", "None")
    field_type_converter["DiscontinuityOpening"] = ("AdditionalDiscontinuityOpening", "None")
    field_type_converter["NodeStatus"] = ("NodeStatus", "None")
    field_type_converter["CellStatus"] = ("CellStatus", "None")

    def __init__(self, path_to_db):
        self.__db = h5py.File(path_to_db, 'r')
        self.__saved_times = sorted([float(x) for x in list(self.__db.keys())])
        self.__nb_saved_times = len(self.saved_times)
        self.__saved_fields = list(self.__db.values())[0].keys()
        self.__saved_fields_type = \
            [k for k, v in list(OutputDatabaseExploit.field_type_converter.items())
             if v[0] in self.__saved_fields]

    @property
    def nb_saved_times(self):
        """
        Return the number of time step that have been saved

        :return: the number of time step that have been saved
        """
        return self.__nb_saved_times

    @property
    def saved_times(self):
        """
        Return the list of saved times

        :return: the list of saved times
        """
        return self.__saved_times

    @property
    def saved_fields(self):
        """
        Return the different fields stored in the database

        :return: the different fields stored in the database
        """
        return self.__saved_fields

    @property
    def saved_fields_type(self):
        """
        Return the different fields type stored in the database

        :return: the different fields type stored in the database
        """
        return self.__saved_fields_type

    def get_cells_true_size_at_time(self, time):
        """
        Return the cells true sizes at time time

        :param time: time at which the cells sizes are computed
        :return: the cells true sizes
        """
        size = np.copy(self.extract_field_at_time("CellSize", time))
        cell_status = np.copy(self.extract_field_at_time("CellStatus", time))
        left_size, right_size = None, None
        try:
            left_size = self.extract_field_at_time("AdditionalLeftSize", time)[:].flatten()[1]
            right_size = self.extract_field_at_time("AdditionalRightSize", time)[:].flatten()[1]
        except KeyError:
            pass
        if left_size is not None and right_size is not None:
            offset = 0
            for stable_index in np.where(cell_status)[0]:
                moving_index = stable_index + offset
                size = np.insert(size, moving_index, [left_size, right_size])
                offset += 2
                size = np.delete(size, stable_index + offset)
        return size

    def get_cells_coordinate(self, time):
        """
        Return the cells center coordinate at time time

        :param time: time at which the cells coordinates are computed
        :return: the cells center coordinates
        """
        # Include the discontinuity opening :
        res = self.get_nodes_coordinates(time)
        node_position = np.copy(res).flatten()
        cell_size = np.copy(self.get_cells_true_size_at_time(time)).flatten()
        cell_status = self.extract_field_at_time("CellStatus", time)

        nbr_cells = len(cell_size)
        nbr_nodes = len(node_position)
        offset = 0

        if nbr_cells == nbr_nodes - 1:
            # ie no enrichment => no right size to insert in the cell_position array
            cell_position = node_position[:-1] + cell_size / 2.
        else:
            # Loop on the enriched cells to find the enriched nodes
            for stable_index in np.sort(np.where(cell_status)[0]):
                # 1D : node left = cell_index and node right = cell_index + 1
                node_droite_index = stable_index + 1 + offset
                # Double the right node because it is used to compute the coordinates of the right
                # part of the cracked cell but also the coordinates of the cell right after the
                # cracked enriched cell
                node_position = np.insert(
                    node_position, node_droite_index, node_position[node_droite_index])
                # Anticipate the correction for right part of the cracked cell (see /!\ below)
                node_position[node_droite_index] -= cell_size[node_droite_index]
                offset += 1

            # Compute the coordinates for each classical cell and left part of enriched cells
            cell_position = node_position[:-1] + cell_size / 2.
            # /!\ With this operation, the coordinates of all the right parts of the cracked cells
            # are bad calculated. For each right cracked cell coordinate, the calculation made is
            # right_part_coord = right_node_coord + right_size / 2
            # The right operation is instead :
            # right_part_coord = right_node_coord - right_size / 2
            # That is why the correction node_position -= cell_size has been made earlier to
            # find the correct coordinates
        return cell_position.reshape((len(cell_size), 1))

    def get_nodes_coordinates(self, time):
        """
        Extract nodes coordinates from database
        """
        coord_item = self.extract_field_at_time("NodeCoordinates", time)
        return coord_item

    def extract_field_at_time(self, field_name, time):
        """
        Return the value of the specified field at time time in a numpy array

        :param field_name: name of the field to be extracted
        :param time: time at which the field has to be extracted
        :return: the values of the field at time time
        """
        ex_time = time
        if ex_time not in self.saved_times:
            ex_time_index = bisect(self.saved_times, time)
            if ex_time_index == self.nb_saved_times:
                ex_time_index = self.nb_saved_times - 1
            try:
                ex_time = self.saved_times[ex_time_index]
            except IndexError:
                print("Specified time is out of range. "
                      "Please specify a time in [{:15.9g}, {:15.9g}]"
                      .format(self.saved_times[0], self.saved_times[-1]), file=sys.stderr)
                raise
        try:
            if ex_time != 0.:
                field = self.__db[str(ex_time)][field_name]
            else:
                field = self.__db['0'][field_name]
        except KeyError:
            if field_name not in self.saved_fields:
                # to deal with the case where AdditionalField is not present in database
                # this is the case when the no enrichment is activated. This should not raise
                # an error as the field name verification has been done earlier
                raise
            print("Unable to retrieve the group {:s}".format(str(ex_time)), file=sys.stderr)
            raise
        return field

    def extract_true_field_at_time(self, field_type, time):
        """
        Return the value of the true field at time time in a numpy array

        :param field_type: type of the true field ("Pressure", "Density" ...)
        :param time: time at which the field has to be extracted
        :return: the values of the true field at time time
        """
        try:
            classical_fname, additional_fname = \
                OutputDatabaseExploit.field_type_converter[field_type]
        except KeyError:
            print("The field type {:s} is not present in the database. "
                  "Available field types are {:s}!"
                  .format(field_type, ",".join(self.saved_fields_type)), file=sys.stderr)
            raise

        classical_f = self.extract_field_at_time(classical_fname, time)

        added_f = None
        coord_item = None
        try:
            added_f = self.extract_field_at_time(additional_fname, time)
        except KeyError:
            pass
        # Support test :
        if "onedimension" not in classical_f.attrs["support"].lower():
            raise TypeError("I am not sure that it is a 1D analysis. "
                            "This may result in errors in the future")

        if added_f is None:  # No enrichment => get classical field
            true_field = classical_f[:]

            if len(true_field.flatten()) == true_field.shape[0]:
                # if scalar field, reshape to get a 2d field with the second dimension = 1
                # Enable to be compatible with the coordinates type and the use of np.concatenate
                true_field = true_field.reshape((len(true_field), 1))

            if "node" in classical_f.attrs["support"].lower():
                coord_item = self.get_nodes_coordinates(time)
            elif "cell" in classical_f.attrs["support"].lower():
                coord_item = self.get_cells_coordinate(time)
            else:
                raise ValueError("Unknown support for field !")

        else:  # If the enriched field exists in database
            if "node" in classical_f.attrs["support"].lower():
                coord_item = self.get_nodes_coordinates(time)
                # build the true field
                true_field = build_node_true_field(classical_f,
                                                   enrichment_type=added_f.attrs["enrichment"])
            elif "cell" in classical_f.attrs["support"].lower():
                coord_item = self.get_cells_coordinate(time)
                # classical_f[:] is an array while classical_f is a data set  => use of array
                true_field = build_cell_true_field(classical_f[:], added_f,
                                                   enrichment_type=added_f.attrs["enrichment"])
            else:
                raise ValueError("Unknown support value!")

        # Build array cell coord / true field for scalar, vector and tensor fields
        # Compatible with the np.concatenate((coord_item, true_field), axis=1) function
        res = np.zeros([len(coord_item), true_field.shape[1] + 1])
        res[:, 0] = coord_item[:, 0]
        res[:, 1] = true_field[:, 0]
        # try to add the tensor fields
        try:
            res[:, 2] = true_field[:, 1]
            res[:, 3] = true_field[:, 2]
        except IndexError:
            # scalar field
            pass
        return res

    def extract_fields_for_cohesive_zone_model(self, cracked_cell_index, time):
        """
        Read database to extract the discontinuity opening, cohesive force and a bool to
        filter results

        :param cracked_cell_index: cell id containing the cohesive zone
        :param time: time which to extract data at
        """
        exist = False
        opening = 0
        force = 0
        current_disc_collection = np.where(self.extract_field_at_time("CellStatus", time))[0]
        if cracked_cell_index in current_disc_collection:
            exist = True
            disc_opening = self.extract_field_at_time("AdditionalDiscontinuityOpening",
                                                      time)[:]  # 2D array : index, opening
            disc_force = self.extract_field_at_time("AdditionalCohesiveForce",
                                                    time)[:]  # 2D array : index, force

            # Find the force and opening values for cracked cell index
            local_indice = np.where(disc_opening[:, 0] == cracked_cell_index)[0][0]
            opening = disc_opening[local_indice, 1]
            force = disc_force[local_indice, 1]
        return exist, opening, force

    def extract_discontinuity_opening(self, time):
        """
        Read database to extract the discontinuity opening, cohesive force and a bool to
        filter results

        :param time: time which to extract data at
        """
        found = True
        try:
            disc_opening = self.extract_field_at_time("AdditionalDiscontinuityOpening",
                                                      time)[:]  # 2D array : index, opening
        except KeyError:
            found = False
            disc_opening = None
        return found, disc_opening
