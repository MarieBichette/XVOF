
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>XVOF Documentation &#8212; XVOF  documentation</title>
    <link rel="stylesheet" href="_static/guzzle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Installation" href="installation.html" />
    <link rel="prev" title="Code organisation" href="organisation.html" />
  
   

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="organisation.html" title="Code organisation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">XVOF  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <h2>Contents</h2>
    <div class="sidebar-localtoc">
      <ul>
<li><a class="reference internal" href="#">XVOF Documentation</a><ul>
<li><a class="reference internal" href="#module-cell">Cell</a></li>
<li><a class="reference internal" href="#module-cohesive_model">Cohesive Zone Model</a></li>
<li><a class="reference internal" href="#module-cohesive_model_unloading">Cohesive Zone Model : unloading options</a></li>
<li><a class="reference internal" href="#module-contact">Contact</a></li>
<li><a class="reference internal" href="#module-custom_functions">Customized Boundary Condition Functions</a></li>
<li><a class="reference internal" href="#module-data">Data</a></li>
<li><a class="reference internal" href="#module-discontinuity">Discontinuity</a></li>
<li><a class="reference internal" href="#module-equationsofstate">Equation Of State</a></li>
<li><a class="reference internal" href="#module-fields">Fields</a></li>
<li><a class="reference internal" href="#module-figure_manager">FigureManager (animation)</a></li>
<li><a class="reference internal" href="#module-mass_matrix">Mass Matrix</a></li>
<li><a class="reference internal" href="#module-mesh">Mesh</a></li>
<li><a class="reference internal" href="#module-node">Nodes</a></li>
<li><a class="reference internal" href="#module-output_manager">Outputs</a></li>
<li><a class="reference internal" href="#module-plasticitycriterion">Plasticity criterion</a></li>
<li><a class="reference internal" href="#module-rheology">Rheology</a></li>
<li><a class="reference internal" href="#module-rupturecriterion">Rupture criterion</a></li>
<li><a class="reference internal" href="#module-rupturetreatment">Rupture treatments</a></li>
<li><a class="reference internal" href="#module-solver">Solver</a></li>
<li><a class="reference internal" href="#module-utilities">Utilities</a></li>
</ul>
</li>
<li><a class="reference internal" href="#index-and-tables">Index and tables</a></li>
</ul>

    </div>
  </div>
</div>
  <h4>Previous topic</h4>
  <p class="topless"><a href="organisation.html"
                        title="previous chapter">Code organisation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="installation.html"
                        title="next chapter">Installation</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/documentation.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
      
    </div>
  </div>
        <div id="right-column">
          
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="index.html">Docs</a></li>
              
              <li>XVOF Documentation</li>
            </ol>
          </div>
          
          <div class="document clearer body">
            
  <div class="section" id="xvof-documentation">
<h1>XVOF Documentation<a class="headerlink" href="#xvof-documentation" title="Permalink to this headline">¶</a></h1>
<p>The time loop is executed in XtentedFiniteVolume.py. Mesh objects are responsible of the cells and nodes objects. So in principle, the entry point calls a mesh method which calls a cell or node method to update variables.
The following documentation specifies the role of all functions and modules in the code.</p>
<div class="section" id="module-cell">
<span id="cell"></span><h2>Cell<a class="headerlink" href="#module-cell" title="Permalink to this headline">¶</a></h2>
<p>Package for cell modules</p>
<dl class="py class">
<dt id="cell.Cell">
<em class="property">class </em><code class="descclassname">cell.</code><code class="descname">Cell</code><span class="sig-paren">(</span><em><span class="n">nbr_of_cells</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.Cell" title="Permalink to this definition">¶</a></dt>
<dd><p>A Cell object represents all the mesh cells.
Its different members are, for most of them, numpy 1D-array of nbr_of_cells length.</p>
<p>Memory layout is the same as in C/C++, i-e ‘row wise’.</p>
<dl class="py method">
<dt id="cell.Cell.compute_mass">
<em class="property">abstract </em><code class="descname">compute_mass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cell.Cell.compute_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mass of the cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.compute_new_density">
<em class="property">abstract </em><code class="descname">compute_new_density</code><span class="sig-paren">(</span><em><span class="n">mask</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.Cell.compute_new_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the new density in the cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.compute_new_pressure">
<em class="property">abstract </em><code class="descname">compute_new_pressure</code><span class="sig-paren">(</span><em><span class="n">mask</span></em>, <em><span class="n">delta_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.Cell.compute_new_pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the pressure in the cells at time t + dt</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.compute_new_pseudo">
<em class="property">abstract </em><code class="descname">compute_new_pseudo</code><span class="sig-paren">(</span><em><span class="n">time_step</span></em>, <em><span class="n">mask</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.Cell.compute_new_pseudo" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the new value of artificial viscosity in the cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.compute_new_size">
<em class="property">abstract </em><code class="descname">compute_new_size</code><span class="sig-paren">(</span><em><span class="o">*</span><span class="n">args</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.Cell.compute_new_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the new size of the cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.compute_new_time_step">
<em class="property">abstract </em><code class="descname">compute_new_time_step</code><span class="sig-paren">(</span><em><span class="n">mask</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.Cell.compute_new_time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the new value of critical time step in the cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.compute_size">
<em class="property">abstract </em><code class="descname">compute_size</code><span class="sig-paren">(</span><em><span class="n">topologie</span></em>, <em><span class="n">vecteur_coord_noeuds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.Cell.compute_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the size of the cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.density">
<em class="property">property </em><code class="descname">density</code><a class="headerlink" href="#cell.Cell.density" title="Permalink to this definition">¶</a></dt>
<dd><p>Density in the cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.dt">
<em class="property">property </em><code class="descname">dt</code><a class="headerlink" href="#cell.Cell.dt" title="Permalink to this definition">¶</a></dt>
<dd><p>Critical time step in cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.energy">
<em class="property">property </em><code class="descname">energy</code><a class="headerlink" href="#cell.Cell.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal energy in the cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.fields_manager">
<em class="property">property </em><code class="descname">fields_manager</code><a class="headerlink" href="#cell.Cell.fields_manager" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the field manager</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.get_coordinates">
<em class="property">classmethod </em><code class="descname">get_coordinates</code><span class="sig-paren">(</span><em><span class="n">nbr_cells</span></em>, <em><span class="n">topology</span></em>, <em><span class="n">x_coord</span></em>, <em><span class="n">y_coord</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">z_coord</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.Cell.get_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vector of cell center coordinates at time t</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first simple">
<li><strong>nbr_cells</strong> – number of cells</li>
<li><strong>topology</strong> (<a class="reference internal" href="#mesh.Topology" title="mesh.Topology"><em>Topology</em></a>) – topology</li>
<li><strong>x_coord</strong> (<em>numpy.array</em><em>(</em><em>[</em><em>nbr_of_cells</em><em>, </em><em>1</em><em>]</em><em>, </em><em>dtype=np.float64</em><em>, </em><em>order='C'</em><em>)</em>) – x coordinate vector</li>
<li><strong>y_coord</strong> (<em>numpy.array</em><em>(</em><em>[</em><em>nbr_of_cells</em><em>, </em><em>1</em><em>]</em><em>, </em><em>dtype=np.float64</em><em>, </em><em>order='C'</em><em>)</em>) – y coordinate vector</li>
<li><strong>z_coord</strong> (<em>numpy.array</em><em>(</em><em>[</em><em>nbr_of_cells</em><em>, </em><em>1</em><em>]</em><em>, </em><em>dtype=np.float64</em><em>, </em><em>order='C'</em><em>)</em>) – z coordinate vector</li>
</ul>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first">the vector of cell center coordinates at time t</p>
</dd>
<dt class="field-name">Return type</dt><dd class="field-body"><p class="first last">numpy.array([nbr_of_cells, topology.dimension], dtype=np.float64, order=’C’)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.increment_variables">
<code class="descname">increment_variables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cell.Cell.increment_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Variables incrementation</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.initialize_cell_fields">
<code class="descname">initialize_cell_fields</code><span class="sig-paren">(</span><em><span class="n">mask_node_target</span></em>, <em><span class="n">mask_node_projectile</span></em>, <em><span class="n">topology</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.Cell.initialize_cell_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialisation of the cell fields and attributes of cell_in_target and cell_in_projectile
:param mask_node_target: bool array for nodes in the target
:param mask_node_projectile: bool array for nodes in the target
:param topology: mesh connectivity object
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.mass">
<em class="property">property </em><code class="descname">mass</code><a class="headerlink" href="#cell.Cell.mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Mass of the cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.number_of_cells">
<em class="property">property </em><code class="descname">number_of_cells</code><a class="headerlink" href="#cell.Cell.number_of_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.pressure">
<em class="property">property </em><code class="descname">pressure</code><a class="headerlink" href="#cell.Cell.pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Pressure in the cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.print_infos">
<code class="descname">print_infos</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cell.Cell.print_infos" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the fields in the cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.pseudo">
<em class="property">property </em><code class="descname">pseudo</code><a class="headerlink" href="#cell.Cell.pseudo" title="Permalink to this definition">¶</a></dt>
<dd><p>Artificial viscosity in the cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.shear_modulus">
<em class="property">property </em><code class="descname">shear_modulus</code><a class="headerlink" href="#cell.Cell.shear_modulus" title="Permalink to this definition">¶</a></dt>
<dd><p>Elastic shear modulus</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.size_t">
<em class="property">property </em><code class="descname">size_t</code><a class="headerlink" href="#cell.Cell.size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Size (length, area, volume) of the cells at time t</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.size_t_plus_dt">
<em class="property">property </em><code class="descname">size_t_plus_dt</code><a class="headerlink" href="#cell.Cell.size_t_plus_dt" title="Permalink to this definition">¶</a></dt>
<dd><p>Size (length, area, volume) of the cells at time t + dt</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.sound_velocity">
<em class="property">property </em><code class="descname">sound_velocity</code><a class="headerlink" href="#cell.Cell.sound_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sound velocity in the cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.stress">
<em class="property">property </em><code class="descname">stress</code><a class="headerlink" href="#cell.Cell.stress" title="Permalink to this definition">¶</a></dt>
<dd><p>Cauchy stress tensor in the cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.stress_xx">
<em class="property">property </em><code class="descname">stress_xx</code><a class="headerlink" href="#cell.Cell.stress_xx" title="Permalink to this definition">¶</a></dt>
<dd><p>Cauchy stress tensor in the cells. 1D : component xx</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.stress_yy">
<em class="property">property </em><code class="descname">stress_yy</code><a class="headerlink" href="#cell.Cell.stress_yy" title="Permalink to this definition">¶</a></dt>
<dd><p>Stress tensor field : sigma_yy</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.stress_zz">
<em class="property">property </em><code class="descname">stress_zz</code><a class="headerlink" href="#cell.Cell.stress_zz" title="Permalink to this definition">¶</a></dt>
<dd><p>Stress tensor field : sigma_zz</p>
</dd></dl>

<dl class="py method">
<dt id="cell.Cell.yield_stress">
<em class="property">property </em><code class="descname">yield_stress</code><a class="headerlink" href="#cell.Cell.yield_stress" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield stress separating elastic from plastic behavior</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cell.OneDimensionCell">
<em class="property">class </em><code class="descclassname">cell.</code><code class="descname">OneDimensionCell</code><span class="sig-paren">(</span><em><span class="n">number_of_elements</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for one dimension cells</p>
<dl class="py method">
<dt id="cell.OneDimensionCell.add_elastic_energy_method">
<em class="property">classmethod </em><code class="descname">add_elastic_energy_method</code><span class="sig-paren">(</span><em><span class="n">dt</span></em>, <em><span class="n">density_current</span></em>, <em><span class="n">density_new</span></em>, <em><span class="n">stress_dev_current</span></em>, <em><span class="n">stress_dev_new</span></em>, <em><span class="n">strain_rate_dev</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.add_elastic_energy_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Take into account the additional term in internal energy due to elasticity</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.apply_equation_of_state">
<em class="property">classmethod </em><code class="descname">apply_equation_of_state</code><span class="sig-paren">(</span><em><span class="n">cell</span><span class="p">:</span> <span class="n">xfv.src.cell.cell.Cell</span></em>, <em><span class="n">eos</span></em>, <em><span class="n">density</span></em>, <em><span class="n">density_new</span></em>, <em><span class="n">pressure</span></em>, <em><span class="n">pressure_new</span></em>, <em><span class="n">energy</span></em>, <em><span class="n">energy_new</span></em>, <em><span class="n">pseudo</span></em>, <em><span class="n">cson_new</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.apply_equation_of_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the equation of state to get the new internal energy, pressure and sound speed
:param cell: cell collection [in]
:param eos: equation of state object [in]
:param density: array of current density [in]
:param density_new: array of new velocity [in]
:param pressure: array of current pressure [in]
:param pressure_new: array of new pressure [out]
:param energy: array of current energy [in]
:param energy_new: array of new energy [out]
:param pseudo: array of artificial viscosity [in]
:param cson_new: array of sound speed [out]</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.apply_plasticity">
<code class="descname">apply_plasticity</code><span class="sig-paren">(</span><em><span class="n">mask</span></em>, <em><span class="n">delta_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.apply_plasticity" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply plasticity treatment if criterion is activated :
- compute yield stress
- tests plasticity criterion
- compute plastic strain rate for plastic cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.artificial_viscosity_field">
<em class="property">property </em><code class="descname">artificial_viscosity_field</code><a class="headerlink" href="#cell.OneDimensionCell.artificial_viscosity_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Pseudoviscosity field</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.classical">
<em class="property">property </em><code class="descname">classical</code><a class="headerlink" href="#cell.OneDimensionCell.classical" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">boolean mask indicating which cells are classical</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.compute_complete_stress_tensor">
<code class="descname">compute_complete_stress_tensor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.compute_complete_stress_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Cauchy stress tensor (assemble pression et dï¿½viateur)</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.compute_deviator_strain_rate">
<em class="property">static </em><code class="descname">compute_deviator_strain_rate</code><span class="sig-paren">(</span><em><span class="n">dt</span></em>, <em><span class="n">topology</span></em>, <em><span class="n">node_coord_new</span></em>, <em><span class="n">node_velocity_new</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.compute_deviator_strain_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute strain rate deviator
:param mask : mask to select classical cells
:param dt : time step
:param topology : table of connectivity : link between cells and nodes id
:param node_coord_new : array with new nodes coordinates
:param node_velocity_new : array with new nodes velocities</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.compute_deviatoric_stress_tensor">
<code class="descname">compute_deviatoric_stress_tensor</code><span class="sig-paren">(</span><em><span class="n">mask</span></em>, <em><span class="n">topology</span></em>, <em><span class="n">node_coord_new</span></em>, <em><span class="n">node_velocity_new</span></em>, <em><span class="n">delta_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.compute_deviatoric_stress_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the deviatoric part of the stress tensor
:param mask : mask to select classical cells
:param topology : table of connectivity : link between cells and nodes id
:param node_coord_new : array with new nodes coordinates (time n+1)
:param node_velocity_new : array with new nodes velocities (time n+1/2)
:param delta_t : time step (staggered tn+1/2)</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.compute_mass">
<code class="descname">compute_mass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.compute_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mass of the cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.compute_new_density">
<code class="descname">compute_new_density</code><span class="sig-paren">(</span><em><span class="n">mask</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.compute_new_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of the density of the cells at time t+dt using mass conservation principle
:param mask : array of boolean to identify classical cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.compute_new_pressure">
<code class="descname">compute_new_pressure</code><span class="sig-paren">(</span><em><span class="n">mask</span></em>, <em><span class="n">dt</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.compute_new_pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of the set (internal energy, pressure, sound velocity) for v-e formulation</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.compute_new_pseudo">
<code class="descname">compute_new_pseudo</code><span class="sig-paren">(</span><em><span class="n">delta_t</span></em>, <em><span class="n">mask</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.compute_new_pseudo" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of cells artificial viscosity at time t+dt
:param delta_t : time step
:param mask : array of boolean to identify classical cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.compute_new_size">
<code class="descname">compute_new_size</code><span class="sig-paren">(</span><em><span class="n">topology</span></em>, <em><span class="n">node_coord</span></em>, <em><span class="n">mask</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.compute_new_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of the cells length at time t+dt
:param topology : table to link nodes and cells index
:param node_coord : array with the new nodes coordinates
:param mask : array of boolean to identify classical cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.compute_new_time_step">
<code class="descname">compute_new_time_step</code><span class="sig-paren">(</span><em><span class="n">mask</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.compute_new_time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of the time step in the cells at time t+dt
:param mask : array of boolean to identify classical cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.compute_pseudo">
<em class="property">classmethod </em><code class="descname">compute_pseudo</code><span class="sig-paren">(</span><em><span class="n">delta_t</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">rho_old</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em><span class="n">rho_new</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em><span class="n">size_new</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em><span class="n">cel_son</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em><span class="n">a_pseudo</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">b_pseudo</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.compute_pseudo" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of artificial viscosity
:param delta_t: time step
:param rho_old: density at time t
:param rho_new: density at time t+dt
:param size_new: cell size at time t+dt
:param cel_son: sound speed at time t
:param a_pseudo: quadratic pseudo coefficient
:param b_pseudo: linear pseudo coefficient</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.compute_shear_modulus">
<code class="descname">compute_shear_modulus</code><span class="sig-paren">(</span><em><span class="n">shear_modulus_model</span></em>, <em><span class="n">mask</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.compute_shear_modulus" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the shear modulus G according to the constitutive elasticity model in XDATA
:param shear_modulus_model : model to compute the shear modulus
:param mask : mask to identify the cells to be computed</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.compute_size">
<code class="descname">compute_size</code><span class="sig-paren">(</span><em><span class="n">topology</span></em>, <em><span class="n">node_coord</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.compute_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of the cells initial length
:param topology : table to link nodes and cells index
:param node_coord : array with nodes coordinates</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.compute_time_step">
<em class="property">classmethod </em><code class="descname">compute_time_step</code><span class="sig-paren">(</span><em><span class="n">cfl</span></em>, <em><span class="n">cfl_pseudo</span></em>, <em><span class="n">rho_old</span></em>, <em><span class="n">rho_new</span></em>, <em><span class="n">size_new</span></em>, <em><span class="n">sound_speed_new</span></em>, <em><span class="n">pseudo_old</span></em>, <em><span class="n">pseudo_new</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.compute_time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of the time step
:param cfl : nombre cfl
:param cfl_pseudo : cfl linked to the shock treatment stability condition
:param rho_old : density at time t
:param rho_new : density at time t+dt
:param size_new : size of element
:param sound_speed_new : sound velocity at time t+dt
:param pseudo_old : artificial viscosity at time t
:param pseudo_new : artificial viscosity at timet+dt</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.compute_yield_stress">
<code class="descname">compute_yield_stress</code><span class="sig-paren">(</span><em><span class="n">yield_stress_model</span></em>, <em><span class="n">mask</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.compute_yield_stress" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the yield stress according to plasticity constitutive model in XDATA
:param yield_stress_model : model to compute the yield stress
:param mask : mask to identify the cells to be computed</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.density_field">
<em class="property">property </em><code class="descname">density_field</code><a class="headerlink" href="#cell.OneDimensionCell.density_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Density field</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.deviatoric_stress_current">
<em class="property">property </em><code class="descname">deviatoric_stress_current</code><a class="headerlink" href="#cell.OneDimensionCell.deviatoric_stress_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current deviatoric stress tensor Sxx Syy Szz</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.deviatoric_stress_new">
<em class="property">property </em><code class="descname">deviatoric_stress_new</code><a class="headerlink" href="#cell.OneDimensionCell.deviatoric_stress_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the new deviatoric stress tensor Sxx Syy Szz</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.energy_field">
<em class="property">property </em><code class="descname">energy_field</code><a class="headerlink" href="#cell.OneDimensionCell.energy_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal energy field</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.enriched">
<em class="property">property </em><code class="descname">enriched</code><a class="headerlink" href="#cell.OneDimensionCell.enriched" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">boolean mask indicating which cells are enriched</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.equivalent_plastic_strain_rate">
<em class="property">property </em><code class="descname">equivalent_plastic_strain_rate</code><a class="headerlink" href="#cell.OneDimensionCell.equivalent_plastic_strain_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the equivalent plastic strain rate</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.general_method_deviator_strain_rate">
<em class="property">static </em><code class="descname">general_method_deviator_strain_rate</code><span class="sig-paren">(</span><em><span class="n">dt</span></em>, <em><span class="n">x_new</span></em>, <em><span class="n">u_new</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.general_method_deviator_strain_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the deviator of strain rate tensor (defined at the center of the cell)
from the coordinates and velocities interpolated at the center of the cell
:param mask : bool array to identify cells to be computed
:param dt : time step (float)
:param x_new : coordinates array at time n+1 of the left and right nodes of each cell
Shape is array([coord_node_left, coord_node_right] * nbr_cells in the mask)
:param u_new : velocity array at time n+1/2 of the left and right nodes of each cell
Shape is array([velocity_node_left, velocity_node_right] * nbr_cells in the mask)
x_new, u_new shape is (size(mask), 2)</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.impose_pressure">
<code class="descname">impose_pressure</code><span class="sig-paren">(</span><em><span class="n">ind_cell</span></em>, <em><span class="n">pressure</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.impose_pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Pressure imposition
:param ind_cell : index of the cells
:param pressure : pressure value to be imposed</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.increment_variables">
<code class="descname">increment_variables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionCell.increment_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment cells variables from one iteration to another</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.plastic_strain_rate">
<em class="property">property </em><code class="descname">plastic_strain_rate</code><a class="headerlink" href="#cell.OneDimensionCell.plastic_strain_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current plastic stain rate tensor Dp_xx Dp_yy Dp_zz</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionCell.pressure_field">
<em class="property">property </em><code class="descname">pressure_field</code><a class="headerlink" href="#cell.OneDimensionCell.pressure_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Pressure field</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cell.OneDimensionHansboEnrichedCell">
<em class="property">class </em><code class="descclassname">cell.</code><code class="descname">OneDimensionHansboEnrichedCell</code><span class="sig-paren">(</span><em><span class="n">number_of_elements</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell" title="Permalink to this definition">¶</a></dt>
<dd><p>A collection of 1d enriched elements. Treatment for Hansbo enrichment</p>
<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.additional_dof_artificial_viscosity">
<em class="property">property </em><code class="descname">additional_dof_artificial_viscosity</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.additional_dof_artificial_viscosity" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional cell artificial viscosity field</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.additional_dof_density">
<em class="property">property </em><code class="descname">additional_dof_density</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.additional_dof_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional cell density field</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.additional_dof_deviatoric_strain_rate">
<em class="property">property </em><code class="descname">additional_dof_deviatoric_strain_rate</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.additional_dof_deviatoric_strain_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional cell deviatoric strain rate at time t</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.additional_dof_deviatoric_stress_current">
<em class="property">property </em><code class="descname">additional_dof_deviatoric_stress_current</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.additional_dof_deviatoric_stress_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional cell deviatoric stress at time t</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.additional_dof_deviatoric_stress_new">
<em class="property">property </em><code class="descname">additional_dof_deviatoric_stress_new</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.additional_dof_deviatoric_stress_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional cell deviatoric stress at time t+dt</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.additional_dof_energy">
<em class="property">property </em><code class="descname">additional_dof_energy</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.additional_dof_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional cell internal energy field</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.additional_dof_equivalent_plastic_strain_rate">
<em class="property">property </em><code class="descname">additional_dof_equivalent_plastic_strain_rate</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.additional_dof_equivalent_plastic_strain_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional cell equivalent plastic strain rate at time t</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.additional_dof_plastic_strain_rate">
<em class="property">property </em><code class="descname">additional_dof_plastic_strain_rate</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.additional_dof_plastic_strain_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional cell plastic strain rate tensor at time t</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.additional_dof_pressure">
<em class="property">property </em><code class="descname">additional_dof_pressure</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.additional_dof_pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional cell pressure field</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.additional_dof_shear_modulus">
<em class="property">property </em><code class="descname">additional_dof_shear_modulus</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.additional_dof_shear_modulus" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional cell shear modulus field</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.additional_dof_sound_velocity">
<em class="property">property </em><code class="descname">additional_dof_sound_velocity</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.additional_dof_sound_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional cell sound speed field</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.additional_dof_stress">
<em class="property">property </em><code class="descname">additional_dof_stress</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.additional_dof_stress" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional cell stress at time t</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.additional_dof_stress_xx">
<em class="property">property </em><code class="descname">additional_dof_stress_xx</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.additional_dof_stress_xx" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional cell stress at time t</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.additional_dof_yield_stress">
<em class="property">property </em><code class="descname">additional_dof_yield_stress</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.additional_dof_yield_stress" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional cell yield stress field</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.apply_plasticity_enr">
<code class="descname">apply_plasticity_enr</code><span class="sig-paren">(</span><em><span class="n">mask_mesh</span></em>, <em><span class="n">delta_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.apply_plasticity_enr" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply plasticity treatment if criterion is activated :        - compute yield stress        - tests plasticity criterion        - compute plastic strain rate for plastic cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.artificial_viscosity_field">
<em class="property">property </em><code class="descname">artificial_viscosity_field</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.artificial_viscosity_field" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">artificial viscosity field</dd>
<dt class="field-name">Return type</dt><dd class="field-body">np.array</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.cell_additional_dof_increment">
<code class="descname">cell_additional_dof_increment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.cell_additional_dof_increment" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the enriched cell variables</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.classical">
<em class="property">property </em><code class="descname">classical</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.classical" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">a mask where True indicate a classical cell</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.compute_discontinuity_borders_velocity">
<em class="property">classmethod </em><code class="descname">compute_discontinuity_borders_velocity</code><span class="sig-paren">(</span><em><span class="n">disc</span></em>, <em><span class="n">node_velocity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.compute_discontinuity_borders_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the velocities of points at the discontinuity border
:param disc: Discontinuity to be considered
:param node_velocity : array with nodes velocity
:return ug : velocity of the discontinuity left boundary
:return ud : velocity of the discontinuity right boundary</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.compute_enriched_deviatoric_strain_rate">
<code class="descname">compute_enriched_deviatoric_strain_rate</code><span class="sig-paren">(</span><em><span class="n">delta_t</span></em>, <em><span class="n">node_coord_new</span></em>, <em><span class="n">node_velocity_new</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.compute_enriched_deviatoric_strain_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute devaiateur du taux de dï¿½formation
:param delta_t : time step
:param node_coord_new : array, new nodes coordinates
:param node_velocity_new : array, new nodes velocity</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.compute_enriched_deviatoric_stress_tensor">
<code class="descname">compute_enriched_deviatoric_stress_tensor</code><span class="sig-paren">(</span><em><span class="n">node_coord_new</span></em>, <em><span class="n">node_velocity_new</span></em>, <em><span class="n">delta_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.compute_enriched_deviatoric_stress_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the deviatoric part of the stress tensor
:param node_coord_new : array, new nodes coordinates
:param node_velocity_new : array, new nodes velocity
:param delta_t : float, time step</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.compute_enriched_elements_new_density">
<code class="descname">compute_enriched_elements_new_density</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.compute_enriched_elements_new_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the new densities for left and right parts of the ruptured element
(from mass conservation equation)</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.compute_enriched_elements_new_part_size">
<code class="descname">compute_enriched_elements_new_part_size</code><span class="sig-paren">(</span><em><span class="n">time_step</span></em>, <em><span class="n">node_velocity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.compute_enriched_elements_new_part_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the new size of each ruptured element part (left size and right size)
:param time_step: time step
:param node_velocity: array, node velocities</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.compute_enriched_elements_new_pressure">
<code class="descname">compute_enriched_elements_new_pressure</code><span class="sig-paren">(</span><em><span class="n">delta_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.compute_enriched_elements_new_pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute pressure, internal energy and sound velocity in left and right parts of
the enriched elements
:param delta_t : time step</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.compute_enriched_elements_new_pseudo">
<code class="descname">compute_enriched_elements_new_pseudo</code><span class="sig-paren">(</span><em><span class="n">delta_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.compute_enriched_elements_new_pseudo" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the new artificial viscosity of the enriched_cells
:param delta_t: time_step</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.compute_enriched_elements_new_time_step">
<code class="descname">compute_enriched_elements_new_time_step</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.compute_enriched_elements_new_time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the new local time step.
The calculation is equivalent to a remeshing time step and thus underestimates the
time step for the enriched cells</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.compute_enriched_shear_modulus">
<code class="descname">compute_enriched_shear_modulus</code><span class="sig-paren">(</span><em><span class="n">shear_modulus_model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.compute_enriched_shear_modulus" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the shear modulus for ruptured cell
:param shear_modulus_model : model to compute the shear modulus</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.compute_enriched_stress_tensor">
<code class="descname">compute_enriched_stress_tensor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.compute_enriched_stress_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the complete enriched stress tensor : sigma = -(p+q) I + S</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.compute_enriched_yield_stress">
<code class="descname">compute_enriched_yield_stress</code><span class="sig-paren">(</span><em><span class="n">yield_stress_model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.compute_enriched_yield_stress" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the yield stress for ruptured cells
:param yield_stress_model : model to compute the yield stress</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.density_field">
<em class="property">property </em><code class="descname">density_field</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.density_field" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">density field</dd>
<dt class="field-name">Return type</dt><dd class="field-body">np.array</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.deviatoric_stress_field">
<em class="property">property </em><code class="descname">deviatoric_stress_field</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.deviatoric_stress_field" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">(deviateur de sigma)_xx field</dd>
<dt class="field-name">Return type</dt><dd class="field-body">np.array</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.energy_field">
<em class="property">property </em><code class="descname">energy_field</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.energy_field" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">energy field</dd>
<dt class="field-name">Return type</dt><dd class="field-body">np.array</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.enriched">
<em class="property">property </em><code class="descname">enriched</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.enriched" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">a mask where True indicates an enrich cell</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.initialize_additional_cell_dof">
<code class="descname">initialize_additional_cell_dof</code><span class="sig-paren">(</span><em><span class="n">disc</span><span class="p">:</span> <span class="n">xfv.src.discontinuity.discontinuity.Discontinuity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.initialize_additional_cell_dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Values to initialize the right part fields when discontinuity disc is created
:param disc : the current discontinuity</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.left_part_size">
<em class="property">property </em><code class="descname">left_part_size</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.left_part_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the size of the left part of cracked cell field</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.pressure_field">
<em class="property">property </em><code class="descname">pressure_field</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.pressure_field" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">pressure field</dd>
<dt class="field-name">Return type</dt><dd class="field-body">np.array</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.print_infos">
<code class="descname">print_infos</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.print_infos" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Printing informations about Elements</dt><dd>A REECRIRE AU PROPRE; NOTATIONS ONT CHANGE</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.reconstruct_enriched_elasto_field">
<code class="descname">reconstruct_enriched_elasto_field</code><span class="sig-paren">(</span><em><span class="n">classical_field</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em><span class="n">enriched_field_name</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.reconstruct_enriched_elasto_field" title="Permalink to this definition">¶</a></dt>
<dd><p>True field reconstruction from the classical and enriched fields
:param classical_field: classical field
:param enriched_field_name: name of the enriched field
:return: complete field
:rtype np.array</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.reconstruct_enriched_hydro_field">
<code class="descname">reconstruct_enriched_hydro_field</code><span class="sig-paren">(</span><em><span class="n">classical_field</span><span class="p">:</span> <span class="n">xfv.src.fields.field.Field</span></em>, <em><span class="n">enriched_field_name</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.reconstruct_enriched_hydro_field" title="Permalink to this definition">¶</a></dt>
<dd><p>True field reconstruction from the classical and enriched fields
:param classical_field: classical field
:param enriched_field_name: name of the enriched field
:return: complete field
:rtype np.array</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.right_part_size">
<em class="property">property </em><code class="descname">right_part_size</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.right_part_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the size of the right part of cracked cell field</p>
</dd></dl>

<dl class="py method">
<dt id="cell.OneDimensionHansboEnrichedCell.stress_xx_field">
<em class="property">property </em><code class="descname">stress_xx_field</code><a class="headerlink" href="#cell.OneDimensionHansboEnrichedCell.stress_xx_field" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">sigma_xx field</dd>
<dt class="field-name">Return type</dt><dd class="field-body">np.array</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cohesive_model">
<span id="cohesive-zone-model"></span><h2>Cohesive Zone Model<a class="headerlink" href="#module-cohesive_model" title="Permalink to this headline">¶</a></h2>
<p>Package for cohesive zone model modules</p>
<dl class="py class">
<dt id="cohesive_model.CohesiveLaw">
<em class="property">class </em><code class="descclassname">cohesive_model.</code><code class="descname">CohesiveLaw</code><span class="sig-paren">(</span><em><span class="n">cohesive_law_points</span><span class="p">:</span> <span class="n">numpy.array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cohesive_model.CohesiveLaw" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for cohesive law implementation</p>
<dl class="py method">
<dt id="cohesive_model.CohesiveLaw.compute_cohesive_force">
<code class="descname">compute_cohesive_force</code><span class="sig-paren">(</span><em><span class="n">opening</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cohesive_model.CohesiveLaw.compute_cohesive_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the cohesive force associated with the given opening</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>opening</strong> – discontinuity opening</dd>
<dt class="field-name">Returns</dt><dd class="field-body">float</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cohesive_model.CohesiveLaw.interpolate_cohesive_law">
<em class="property">classmethod </em><code class="descname">interpolate_cohesive_law</code><span class="sig-paren">(</span><em><span class="n">opening</span></em>, <em><span class="n">separation_1</span></em>, <em><span class="n">separation_2</span></em>, <em><span class="n">stress_1</span></em>, <em><span class="n">stress_2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cohesive_model.CohesiveLaw.interpolate_cohesive_law" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate the value of cohesive stress between points 1 and 2</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>opening</strong> – discontinuity opening</dd>
</dl>
<p>:param separation_1 : separation at point 1
:param separation_2 : separation at point 2
:param stress_1 : stress at point 1
:param stress_2 : stress at point 2
:return: cohesive stress</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cohesive_model.CohesiveZoneModel">
<em class="property">class </em><code class="descclassname">cohesive_model.</code><code class="descname">CohesiveZoneModel</code><span class="sig-paren">(</span><em><span class="n">cohesive_law_points</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em><span class="n">unloading_model</span><span class="p">:</span> <span class="n">xfv.src.cohesive_model_unloading.unloading_model_base.UnloadingModelBase</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cohesive_model.CohesiveZoneModel" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for the computation of the cohesive force</p>
<dl class="py method">
<dt id="cohesive_model.CohesiveZoneModel.compute_cohesive_stress">
<code class="descname">compute_cohesive_stress</code><span class="sig-paren">(</span><em><span class="n">disc</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cohesive_model.CohesiveZoneModel.compute_cohesive_stress" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cohesive force for the current opening of discontinuity according to the
current discontinuity opening
:param disc :discontinuity</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cohesive_model_unloading">
<span id="cohesive-zone-model-unloading-options"></span><h2>Cohesive Zone Model : unloading options<a class="headerlink" href="#module-cohesive_model_unloading" title="Permalink to this headline">¶</a></h2>
<p>Package for unloading the cohesive zone model modules</p>
<dl class="py class">
<dt id="cohesive_model_unloading.UnloadingModelBase">
<em class="property">class </em><code class="descclassname">cohesive_model_unloading.</code><code class="descname">UnloadingModelBase</code><span class="sig-paren">(</span><em><span class="o">*</span><span class="n">args</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cohesive_model_unloading.UnloadingModelBase" title="Permalink to this definition">¶</a></dt>
<dd><p>A model for unloading reloading path in cohesive zone model</p>
<dl class="py method">
<dt id="cohesive_model_unloading.UnloadingModelBase.compute_unloading_reloading_condition">
<em class="property">abstract </em><code class="descname">compute_unloading_reloading_condition</code><span class="sig-paren">(</span><em><span class="n">disc</span></em>, <em><span class="n">new_opening</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cohesive_model_unloading.UnloadingModelBase.compute_unloading_reloading_condition" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cohesive stress in case of unloading or reloading condition
(new_opening is less than the discontinuity maximal opening
:param disc : discontinuity
:param new_opening : opening of the discontinuity
:return: cohesive stress (float)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cohesive_model_unloading.ConstantStiffnessUnloading">
<em class="property">class </em><code class="descclassname">cohesive_model_unloading.</code><code class="descname">ConstantStiffnessUnloading</code><span class="sig-paren">(</span><em><span class="n">slope</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cohesive_model_unloading.ConstantStiffnessUnloading" title="Permalink to this definition">¶</a></dt>
<dd><p>A model for unloading reloading path with constant stiffness</p>
<dl class="py method">
<dt id="cohesive_model_unloading.ConstantStiffnessUnloading.compute_unloading_reloading_condition">
<code class="descname">compute_unloading_reloading_condition</code><span class="sig-paren">(</span><em><span class="n">disc</span></em>, <em><span class="n">new_opening</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cohesive_model_unloading.ConstantStiffnessUnloading.compute_unloading_reloading_condition" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cohesive stress in case of unloading or reloading condition
(new_opening is less than the discontinuity maximal opening
:param disc : discontinuity
:param new_opening : opening of the discontinuity
:return: cohesive stress (float)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cohesive_model_unloading.LossOfStiffnessUnloading">
<em class="property">class </em><code class="descclassname">cohesive_model_unloading.</code><code class="descname">LossOfStiffnessUnloading</code><a class="headerlink" href="#cohesive_model_unloading.LossOfStiffnessUnloading" title="Permalink to this definition">¶</a></dt>
<dd><p>A model for unloading reloading path with decreasing stiffness</p>
<dl class="py method">
<dt id="cohesive_model_unloading.LossOfStiffnessUnloading.compute_unloading_reloading_condition">
<code class="descname">compute_unloading_reloading_condition</code><span class="sig-paren">(</span><em><span class="n">disc</span></em>, <em><span class="n">new_opening</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cohesive_model_unloading.LossOfStiffnessUnloading.compute_unloading_reloading_condition" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cohesive stress in case of unloading or reloading condition
(new_opening is less than the discontinuity maximal opening
:param disc : discontinuity
:param new_opening : opening of the discontinuity
:return: cohesive stress (float)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-contact">
<span id="contact"></span><h2>Contact<a class="headerlink" href="#module-contact" title="Permalink to this headline">¶</a></h2>
<p>Package for contact modules</p>
<dl class="py class">
<dt id="contact.ContactBase">
<em class="property">class </em><code class="descclassname">contact.</code><code class="descname">ContactBase</code><span class="sig-paren">(</span><em><span class="o">*</span><span class="n">args</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#contact.ContactBase" title="Permalink to this definition">¶</a></dt>
<dd><p>An interface for all cohesive zone model</p>
<dl class="py method">
<dt id="contact.ContactBase.compute_contact_force">
<em class="property">abstract </em><code class="descname">compute_contact_force</code><span class="sig-paren">(</span><em><span class="n">node_velocity</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em><span class="n">disc</span><span class="p">:</span> <span class="n">xfv.src.discontinuity.discontinuity.Discontinuity</span></em>, <em><span class="n">delta_t</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#contact.ContactBase.compute_contact_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if contact and apply correction
:param node_coord: node coordinates array
:param node_velocity: node velocity array
:param node_force : node force array
:param disc: discontinuity to examine
:param delta_t : time step</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="contact.LagrangianMultiplierContact">
<em class="property">class </em><code class="descclassname">contact.</code><code class="descname">LagrangianMultiplierContact</code><a class="headerlink" href="#contact.LagrangianMultiplierContact" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for contact management using Lagrangian multipliers</p>
<dl class="py method">
<dt id="contact.LagrangianMultiplierContact.compute_contact_force">
<code class="descname">compute_contact_force</code><span class="sig-paren">(</span><em><span class="n">node_velocity</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em><span class="n">disc</span><span class="p">:</span> <span class="n">xfv.src.discontinuity.discontinuity.Discontinuity</span></em>, <em><span class="n">delta_t</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#contact.LagrangianMultiplierContact.compute_contact_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if contact and apply correction
:param node_velocity: node velocity array
:param disc: discontinuity to examine
:param delta_t : time step</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="contact.PenaltyContact">
<em class="property">class </em><code class="descclassname">contact.</code><code class="descname">PenaltyContact</code><span class="sig-paren">(</span><em><span class="n">penalty_stiffness</span></em><span class="sig-paren">)</span><a class="headerlink" href="#contact.PenaltyContact" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to manage contacts using penalty method</p>
<dl class="py method">
<dt id="contact.PenaltyContact.compute_contact_force">
<code class="descname">compute_contact_force</code><span class="sig-paren">(</span><em><span class="n">node_velocity</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em><span class="n">disc</span><span class="p">:</span> <span class="n">xfv.src.discontinuity.discontinuity.Discontinuity</span></em>, <em><span class="n">delta_t</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#contact.PenaltyContact.compute_contact_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if contact and apply correction
:param node_velocity: node velocity array
:param disc: discontinuity to examine
:param delta_t : time step</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-custom_functions">
<span id="customized-boundary-condition-functions"></span><h2>Customized Boundary Condition Functions<a class="headerlink" href="#module-custom_functions" title="Permalink to this headline">¶</a></h2>
<p>Package for customized boundary condition shape functions modules</p>
<dl class="py class">
<dt id="custom_functions.CustomFunction">
<em class="property">class </em><code class="descclassname">custom_functions.</code><code class="descname">CustomFunction</code><a class="headerlink" href="#custom_functions.CustomFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>A generic CustomFunction class that should be used to derive
more specific custom function class</p>
<dl class="py method">
<dt id="custom_functions.CustomFunction.is_pressure">
<code class="descname">is_pressure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#custom_functions.CustomFunction.is_pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the instance is a pressure</p>
</dd></dl>

<dl class="py method">
<dt id="custom_functions.CustomFunction.is_velocity">
<code class="descname">is_velocity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#custom_functions.CustomFunction.is_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the instance is a velocity</p>
</dd></dl>

<dl class="py method">
<dt id="custom_functions.CustomFunction.register_pressure">
<code class="descname">register_pressure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#custom_functions.CustomFunction.register_pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Register the current instance as a pressure</p>
</dd></dl>

<dl class="py method">
<dt id="custom_functions.CustomFunction.register_velocity">
<code class="descname">register_velocity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#custom_functions.CustomFunction.register_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Register the current instance as a velocity</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="custom_functions.ConstantValue">
<em class="property">class </em><code class="descclassname">custom_functions.</code><code class="descname">ConstantValue</code><span class="sig-paren">(</span><em><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#custom_functions.ConstantValue" title="Permalink to this definition">¶</a></dt>
<dd><p>This class defines a function that returns a constant value</p>
<blockquote>
<div>^</div></blockquote>
<dl class="docutils">
<dt>value|……………..</dt><dd><div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<p><a href="#id1"><span class="problematic" id="id2">|</span></a>_________________&gt;</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="custom_functions.MarchTable">
<em class="property">class </em><code class="descclassname">custom_functions.</code><code class="descname">MarchTable</code><span class="sig-paren">(</span><em><span class="n">data_file</span></em><span class="sig-paren">)</span><a class="headerlink" href="#custom_functions.MarchTable" title="Permalink to this definition">¶</a></dt>
<dd><p>This class defines a value interpolated from a text file</p>
<dl class="py method">
<dt id="custom_functions.MarchTable.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em><span class="n">time</span></em>, <em><span class="o">*</span><span class="n">args</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#custom_functions.MarchTable.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of the for the time given in argument</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>time</strong> – current time</dd>
<dt class="field-name">Returns</dt><dd class="field-body">the value</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="custom_functions.Ramp">
<em class="property">class </em><code class="descclassname">custom_functions.</code><code class="descname">Ramp</code><span class="sig-paren">(</span><em><span class="n">first_value</span></em>, <em><span class="n">second_value</span></em>, <em><span class="n">start_time</span></em>, <em><span class="n">end_time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#custom_functions.Ramp" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that defines a ramp between 2 constants steps</p>
<blockquote>
<div>^</div></blockquote>
<dl class="docutils">
<dt>second value|       ………..</dt><dd><div class="line-block">
<div class="line-block">
<div class="line">/</div>
</div>
<div class="line">/</div>
</div>
</dd>
<dt>first value <a href="#id3"><span class="problematic" id="id4">|</span></a>…./</dt><dd><dl class="docutils">
<dt><a href="#id5"><span class="problematic" id="id6">|</span></a>_________________&gt;</dt><dd>start end</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="custom_functions.Ramp.end_time">
<em class="property">property </em><code class="descname">end_time</code><a class="headerlink" href="#custom_functions.Ramp.end_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the time at which the slope ends</p>
</dd></dl>

<dl class="py method">
<dt id="custom_functions.Ramp.first_value">
<em class="property">property </em><code class="descname">first_value</code><a class="headerlink" href="#custom_functions.Ramp.first_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the first value</p>
</dd></dl>

<dl class="py method">
<dt id="custom_functions.Ramp.second_value">
<em class="property">property </em><code class="descname">second_value</code><a class="headerlink" href="#custom_functions.Ramp.second_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the second value</p>
</dd></dl>

<dl class="py method">
<dt id="custom_functions.Ramp.start_time">
<em class="property">property </em><code class="descname">start_time</code><a class="headerlink" href="#custom_functions.Ramp.start_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the time at which the slope begins</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="custom_functions.SuccessiveRamp">
<em class="property">class </em><code class="descclassname">custom_functions.</code><code class="descname">SuccessiveRamp</code><span class="sig-paren">(</span><em><span class="n">first_p_ramp</span></em>, <em><span class="n">second_p_ramp</span></em><span class="sig-paren">)</span><a class="headerlink" href="#custom_functions.SuccessiveRamp" title="Permalink to this definition">¶</a></dt>
<dd><p>This class chains two Ramp functions</p>
</dd></dl>

<dl class="py class">
<dt id="custom_functions.TwoSteps">
<em class="property">class </em><code class="descclassname">custom_functions.</code><code class="descname">TwoSteps</code><span class="sig-paren">(</span><em><span class="n">first_value</span></em>, <em><span class="n">second_value</span></em>, <em><span class="n">critical_time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#custom_functions.TwoSteps" title="Permalink to this definition">¶</a></dt>
<dd><p>This class defines a 2 constant steps function</p>
<blockquote>
<div>^</div></blockquote>
<dl class="docutils">
<dt>second value|    ………..</dt><dd><div class="line-block">
<div class="line"><a href="#id7"><span class="problematic" id="id8">|</span></a></div>
<div class="line"><a href="#id9"><span class="problematic" id="id10">|</span></a></div>
</div>
</dd>
<dt>first value <a href="#id13"><span class="problematic" id="id14">|....|</span></a></dt><dd><dl class="docutils">
<dt><a href="#id11"><span class="problematic" id="id12">|</span></a>_________________&gt;</dt><dd>critical time</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-data">
<span id="data"></span><h2>Data<a class="headerlink" href="#module-data" title="Permalink to this headline">¶</a></h2>
<p>Package for reading the case data modules</p>
<dl class="py class">
<dt id="data.DataContainer">
<em class="property">class </em><code class="descclassname">data.</code><code class="descname">DataContainer</code><span class="sig-paren">(</span><em><span class="n">datafile_path</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>str<span class="p">, </span>pathlib.Path<span class="p">]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#data.DataContainer" title="Permalink to this definition">¶</a></dt>
<dd><p>This class provides access to all the data found in the json datafile</p>
</dd></dl>

</div>
<div class="section" id="module-discontinuity">
<span id="discontinuity"></span><h2>Discontinuity<a class="headerlink" href="#module-discontinuity" title="Permalink to this headline">¶</a></h2>
<p>Package for discontinuity modules</p>
<dl class="py class">
<dt id="discontinuity.Discontinuity">
<em class="property">class </em><code class="descclassname">discontinuity.</code><code class="descname">Discontinuity</code><span class="sig-paren">(</span><em><span class="n">cell_id</span><span class="p">:</span> <span class="n">int</span></em>, <em><span class="n">mask_in_nodes</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em><span class="n">mask_out_nodes</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em><span class="n">discontinuity_position_in_ruptured_element</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">enriched_mass_matrix_props</span><span class="p">:</span> <span class="n">xfv.src.data.enriched_mass_matrix_props.EnrichedMassMatrixProps</span></em><span class="sig-paren">)</span><a class="headerlink" href="#discontinuity.Discontinuity" title="Permalink to this definition">¶</a></dt>
<dd><p>A class describing a discontinuity 1D</p>
<dl class="py method">
<dt id="discontinuity.Discontinuity.additional_dof_coordinates_current">
<em class="property">property </em><code class="descname">additional_dof_coordinates_current</code><a class="headerlink" href="#discontinuity.Discontinuity.additional_dof_coordinates_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional nodes coordinates at time t</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.additional_dof_coordinates_new">
<em class="property">property </em><code class="descname">additional_dof_coordinates_new</code><a class="headerlink" href="#discontinuity.Discontinuity.additional_dof_coordinates_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional nodes coordinates at time t+dt</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.additional_dof_force">
<em class="property">property </em><code class="descname">additional_dof_force</code><a class="headerlink" href="#discontinuity.Discontinuity.additional_dof_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional nodes force at time t</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.additional_dof_increment">
<code class="descname">additional_dof_increment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#discontinuity.Discontinuity.additional_dof_increment" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the variables of discontinuity</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.additional_dof_velocity_current">
<em class="property">property </em><code class="descname">additional_dof_velocity_current</code><a class="headerlink" href="#discontinuity.Discontinuity.additional_dof_velocity_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional nodes velocity at time t-dt/2</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.additional_dof_velocity_new">
<em class="property">property </em><code class="descname">additional_dof_velocity_new</code><a class="headerlink" href="#discontinuity.Discontinuity.additional_dof_velocity_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the additional nodes velocity at time t+dt/2</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.compute_discontinuity_new_opening">
<code class="descname">compute_discontinuity_new_opening</code><span class="sig-paren">(</span><em><span class="n">node_position</span><span class="p">:</span> <span class="n">numpy.array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#discontinuity.Discontinuity.compute_discontinuity_new_opening" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the discontinuity opening
:param node_position: coordinates of the nodes</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.discontinuity_list">
<em class="property">classmethod </em><code class="descname">discontinuity_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#discontinuity.Discontinuity.discontinuity_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the list of all existing discontinuities</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.discontinuity_number">
<em class="property">classmethod </em><code class="descname">discontinuity_number</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#discontinuity.Discontinuity.discontinuity_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of existing discontinuities</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.discontinuity_position">
<em class="property">property </em><code class="descname">discontinuity_position</code><a class="headerlink" href="#discontinuity.Discontinuity.discontinuity_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the discontinuity position</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.get_discontinuity_associated_with_cell">
<em class="property">classmethod </em><code class="descname">get_discontinuity_associated_with_cell</code><span class="sig-paren">(</span><em><span class="n">cell_id</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="headerlink" href="#discontinuity.Discontinuity.get_discontinuity_associated_with_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Loop on the discontinuities collection to find the one that contain the cell cell_id
:param cell_id: cell id to find
:return: Discontinuity or None if no disc is found</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.has_mass_matrix_been_computed">
<code class="descname">has_mass_matrix_been_computed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#discontinuity.Discontinuity.has_mass_matrix_been_computed" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the __mass_matrix_updated boolean to True</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.label">
<em class="property">property </em><code class="descname">label</code><a class="headerlink" href="#discontinuity.Discontinuity.label" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on label variable
:return: label</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.mask_disc_nodes">
<em class="property">property </em><code class="descname">mask_disc_nodes</code><a class="headerlink" href="#discontinuity.Discontinuity.mask_disc_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the mask on the nodes of the discontinuity
:return: the mask on the nodes “concerned” by the discontinuity</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.mask_in_nodes">
<em class="property">property </em><code class="descname">mask_in_nodes</code><a class="headerlink" href="#discontinuity.Discontinuity.mask_in_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the mask on the nodes “in” the discontinuity
:return: the mask on the nodes “in” the discontinuity</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.mask_out_nodes">
<em class="property">property </em><code class="descname">mask_out_nodes</code><a class="headerlink" href="#discontinuity.Discontinuity.mask_out_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the mask on the nodes “out” the discontinuity
:return: the mask on the nodes “out” the discontinuity</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.mask_ruptured_cell">
<em class="property">property </em><code class="descname">mask_ruptured_cell</code><a class="headerlink" href="#discontinuity.Discontinuity.mask_ruptured_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a mask to identify the ruptured cell associated with discontinuity</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.mass_matrix_updated">
<em class="property">property </em><code class="descname">mass_matrix_updated</code><a class="headerlink" href="#discontinuity.Discontinuity.mass_matrix_updated" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the boolean that indicates if the mass matrix has been computed
:return: the boolean that indicates if the mass matrix has been computed</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.position_in_ruptured_element">
<em class="property">property </em><code class="descname">position_in_ruptured_element</code><a class="headerlink" href="#discontinuity.Discontinuity.position_in_ruptured_element" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the relative position of the discontinuity in ruptured element</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.reinitialize_kinematics_after_contact">
<code class="descname">reinitialize_kinematics_after_contact</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#discontinuity.Discontinuity.reinitialize_kinematics_after_contact" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the new velocity to the old one to cancel the increment that has lead to contact</p>
</dd></dl>

<dl class="py method">
<dt id="discontinuity.Discontinuity.ruptured_cell_id">
<em class="property">property </em><code class="descname">ruptured_cell_id</code><a class="headerlink" href="#discontinuity.Discontinuity.ruptured_cell_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the id of ruptured cell for the discontinuity</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-equationsofstate">
<span id="equation-of-state"></span><h2>Equation Of State<a class="headerlink" href="#module-equationsofstate" title="Permalink to this headline">¶</a></h2>
<p>Package for equation of state modules</p>
<dl class="py class">
<dt id="equationsofstate.EquationOfStateBase">
<em class="property">class </em><code class="descclassname">equationsofstate.</code><code class="descname">EquationOfStateBase</code><a class="headerlink" href="#equationsofstate.EquationOfStateBase" title="Permalink to this definition">¶</a></dt>
<dd><p>An interface for all equation of states</p>
<dl class="py method">
<dt id="equationsofstate.EquationOfStateBase.solve_volume_energy">
<em class="property">abstract </em><code class="descname">solve_volume_energy</code><span class="sig-paren">(</span><em><span class="n">specific_volume</span></em>, <em><span class="n">internal_energy</span></em>, <em><span class="n">pressure</span></em>, <em><span class="n">derivative</span></em>, <em><span class="n">vson</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#equationsofstate.EquationOfStateBase.solve_volume_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the eos with [v, e] formulation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="equationsofstate.MieGruneisen">
<em class="property">class </em><code class="descclassname">equationsofstate.</code><code class="descname">MieGruneisen</code><span class="sig-paren">(</span><em><span class="n">czero</span><span class="o">=</span><span class="default_value">3940.0</span></em>, <em><span class="n">S1</span><span class="o">=</span><span class="default_value">1.489</span></em>, <em><span class="n">S2</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em><span class="n">S3</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em><span class="n">rhozero</span><span class="o">=</span><span class="default_value">8930.0</span></em>, <em><span class="n">grunzero</span><span class="o">=</span><span class="default_value">2.02</span></em>, <em><span class="n">b</span><span class="o">=</span><span class="default_value">0.47</span></em>, <em><span class="n">ezero</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#equationsofstate.MieGruneisen" title="Permalink to this definition">¶</a></dt>
<dd><p>Mie Gruneisen equation of state</p>
<dl class="py method">
<dt id="equationsofstate.MieGruneisen.eos_param">
<em class="property">property </em><code class="descname">eos_param</code><a class="headerlink" href="#equationsofstate.MieGruneisen.eos_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on equation of state parameters
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="equationsofstate.MieGruneisen.solve_volume_energy">
<code class="descname">solve_volume_energy</code><span class="sig-paren">(</span><em><span class="n">specific_volume</span></em>, <em><span class="n">internal_energy</span></em>, <em><span class="n">pressure</span></em>, <em><span class="n">derivative</span></em>, <em><span class="n">vson</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#equationsofstate.MieGruneisen.solve_volume_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the specific volume and internal energy computes the pressure, sound speed and
derivative of the pressure with respect to the internal energy</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first last simple">
<li><strong>specific_volume</strong> (<em>numpy.array</em>) – specific volume (in)</li>
<li><strong>internal_energy</strong> (<em>numpy.array</em>) – internal energy (in)</li>
<li><strong>pressure</strong> (<em>numpy.array</em>) – pressure (out)</li>
<li><strong>derivative</strong> (<em>numpy.array</em>) – derivative of pressure with respect to the internal energy (out)</li>
<li><strong>vson</strong> (<em>numpy.array</em>) – sound speed (out)</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-fields">
<span id="fields"></span><h2>Fields<a class="headerlink" href="#module-fields" title="Permalink to this headline">¶</a></h2>
<p>Package for field management modules</p>
<dl class="py class">
<dt id="fields.Field">
<em class="property">class </em><code class="descclassname">fields.</code><code class="descname">Field</code><span class="sig-paren">(</span><em><span class="n">size</span></em>, <em><span class="n">current_value</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em><span class="n">new_value</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#fields.Field" title="Permalink to this definition">¶</a></dt>
<dd><p>Classical physical field on cells or nodes. Owning current and future values in numpy.arrays</p>
<dl class="py method">
<dt id="fields.Field.current_value">
<em class="property">property </em><code class="descname">current_value</code><a class="headerlink" href="#fields.Field.current_value" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">the current field value</dd>
<dt class="field-name">Return type</dt><dd class="field-body">numpy.array</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="fields.Field.increment_values">
<code class="descname">increment_values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fields.Field.increment_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment field values</p>
</dd></dl>

<dl class="py method">
<dt id="fields.Field.new_value">
<em class="property">property </em><code class="descname">new_value</code><a class="headerlink" href="#fields.Field.new_value" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">the future field value</dd>
<dt class="field-name">Return type</dt><dd class="field-body">numpy.array</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="fields.Field.size">
<em class="property">property </em><code class="descname">size</code><a class="headerlink" href="#fields.Field.size" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">the size of the field (i.e number of cells or nodes on which the field is defined)</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="fields.FieldManager">
<em class="property">class </em><code class="descclassname">fields.</code><code class="descname">FieldManager</code><a class="headerlink" href="#fields.FieldManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Field manager class</p>
<dl class="py method">
<dt id="fields.FieldManager.increment_fields">
<code class="descname">increment_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fields.FieldManager.increment_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment all the fields registered in the manager</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-figure_manager">
<span id="figuremanager-animation"></span><h2>FigureManager (animation)<a class="headerlink" href="#module-figure_manager" title="Permalink to this headline">¶</a></h2>
<p>Package for figure management modules</p>
<dl class="py class">
<dt id="figure_manager.PhysicFigure">
<em class="property">class </em><code class="descclassname">figure_manager.</code><code class="descname">PhysicFigure</code><span class="sig-paren">(</span><em><span class="n">X</span></em>, <em><span class="n">Y</span></em>, <em><span class="n">xlabel</span><span class="o">=</span><span class="default_value">'X'</span></em>, <em><span class="n">ylabel</span><span class="o">=</span><span class="default_value">'Y'</span></em>, <em><span class="n">titre</span><span class="o">=</span><span class="default_value">'titre'</span></em>, <em><span class="n">interface_id</span><span class="o">=</span><span class="default_value">0</span></em>, <em><span class="n">save_path</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#figure_manager.PhysicFigure" title="Permalink to this definition">¶</a></dt>
<dd><p>Figure</p>
<dl class="py method">
<dt id="figure_manager.PhysicFigure.set_x_limit">
<code class="descname">set_x_limit</code><span class="sig-paren">(</span><em><span class="n">val_min</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em><span class="n">val_max</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#figure_manager.PhysicFigure.set_x_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fixation des limites en x</p>
</dd></dl>

<dl class="py method">
<dt id="figure_manager.PhysicFigure.set_y_limit">
<code class="descname">set_y_limit</code><span class="sig-paren">(</span><em><span class="n">val_min</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em><span class="n">val_max</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#figure_manager.PhysicFigure.set_y_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fixation des limites en y</p>
</dd></dl>

<dl class="py method">
<dt id="figure_manager.PhysicFigure.update">
<code class="descname">update</code><span class="sig-paren">(</span><em><span class="n">abscissa</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">ordinate</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">title_comp</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#figure_manager.PhysicFigure.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update image to get animation
And save the image if a path is given</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="figure_manager.FigureManager">
<em class="property">class </em><code class="descclassname">figure_manager.</code><code class="descname">FigureManager</code><span class="sig-paren">(</span><em><span class="n">mesh_instance</span></em>, <em><span class="n">dump</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#figure_manager.FigureManager" title="Permalink to this definition">¶</a></dt>
<dd><p>A manager for figures and animations during calculation</p>
<dl class="py method">
<dt id="figure_manager.FigureManager.create_figure_for_cell_field">
<code class="descname">create_figure_for_cell_field</code><span class="sig-paren">(</span><em><span class="n">field_x</span></em>, <em><span class="n">field_y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#figure_manager.FigureManager.create_figure_for_cell_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation of figures for cell fields
:param field_x: abscissa of the figure
:param field_y: ordinate of the figure
Abscissa is thus the cell coordinates</p>
</dd></dl>

<dl class="py method">
<dt id="figure_manager.FigureManager.create_figure_for_node_field">
<code class="descname">create_figure_for_node_field</code><span class="sig-paren">(</span><em><span class="n">field_x</span></em>, <em><span class="n">field_y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#figure_manager.FigureManager.create_figure_for_node_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation of figures for nodal fields
:param field_x: abscissa of the figure
:param field_y: ordinate of the figure
Abscissa is thus the node coordinates</p>
</dd></dl>

<dl class="py method">
<dt id="figure_manager.FigureManager.create_reps">
<code class="descname">create_reps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#figure_manager.FigureManager.create_reps" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation of the reps where data is saved</p>
</dd></dl>

<dl class="py method">
<dt id="figure_manager.FigureManager.populate_figs">
<code class="descname">populate_figs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#figure_manager.FigureManager.populate_figs" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation of the figures associtated with fields and add to the list of figures</p>
</dd></dl>

<dl class="py method">
<dt id="figure_manager.FigureManager.set_iteration_controler">
<code class="descname">set_iteration_controler</code><span class="sig-paren">(</span><em><span class="n">deltat_it</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#figure_manager.FigureManager.set_iteration_controler" title="Permalink to this definition">¶</a></dt>
<dd><p>The figures will be updated every delta_it iterations</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>deltat_it</strong> – interval between two figures</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="figure_manager.FigureManager.set_time_controler">
<code class="descname">set_time_controler</code><span class="sig-paren">(</span><em><span class="n">deltat_t</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#figure_manager.FigureManager.set_time_controler" title="Permalink to this definition">¶</a></dt>
<dd><p>The figures will be updated every delta_t seconds</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>deltat_t</strong> – interval between two figures</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="figure_manager.FigureManager.update">
<code class="descname">update</code><span class="sig-paren">(</span><em><span class="n">time</span></em>, <em><span class="n">iteration</span></em><span class="sig-paren">)</span><a class="headerlink" href="#figure_manager.FigureManager.update" title="Permalink to this definition">¶</a></dt>
<dd><p>If the current time given in argument is above the time of next output then
the manager asks each of its database to save fields. It’s the same for
a current iteration above the iteration of next output
:param time : simulation time
:param iteration : id of the current iteration</p>
</dd></dl>

<dl class="py method">
<dt id="figure_manager.FigureManager.update_fields">
<code class="descname">update_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#figure_manager.FigureManager.update_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the fields to plot using the mesh update methods</p>
</dd></dl>

<dl class="py method">
<dt id="figure_manager.FigureManager.update_figs">
<code class="descname">update_figs</code><span class="sig-paren">(</span><em><span class="n">title_compl</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#figure_manager.FigureManager.update_figs" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the fields and the associated figures
:param title_compl: title of the figure</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-mass_matrix">
<span id="mass-matrix"></span><h2>Mass Matrix<a class="headerlink" href="#module-mass_matrix" title="Permalink to this headline">¶</a></h2>
<p>Package for mass matrix modules</p>
<dl class="py class">
<dt id="mass_matrix.EnrichedMassMatrix">
<em class="property">class </em><code class="descclassname">mass_matrix.</code><code class="descname">EnrichedMassMatrix</code><span class="sig-paren">(</span><em><span class="n">size_of_mass_matrix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to factorize code for the enriched mass matrix</p>
<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrix.assemble_enriched_mass_matrix">
<em class="property">abstract </em><code class="descname">assemble_enriched_mass_matrix</code><span class="sig-paren">(</span><em><span class="o">*</span><span class="n">sub_matrix_names</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrix.assemble_enriched_mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble and inverse the mass matrix after enrichment</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrix.compute_enriched_mass_matrix">
<code class="descname">compute_enriched_mass_matrix</code><span class="sig-paren">(</span><em><span class="n">discontinuity</span></em>, <em><span class="n">topology</span></em>, <em><span class="n">cells_mass</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrix.compute_enriched_mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the enriched mass matrix for Hansbo shape functions
(associated with 1 discontinuity)
:param discontinuity : discontinuity to be considered
:param topology: topology = connectivity
:param cells_mass: array of cells mass</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrix.compute_enriched_mass_matrix_left_part">
<em class="property">abstract </em><code class="descname">compute_enriched_mass_matrix_left_part</code><span class="sig-paren">(</span><em><span class="n">mass_0</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">mass_1</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">epsilon</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrix.compute_enriched_mass_matrix_left_part" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Hansbo mass matrix for the left part
DDL are organized : 0 : N1g and 1 : N2g
:param mass_0: mass of the element right on the left of the cracked cell
:param mass_1 : mass of the cracked cell
:param epsilon: relative position of the disc inside the cracked cell</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrix.compute_enriched_mass_matrix_right_part">
<em class="property">abstract </em><code class="descname">compute_enriched_mass_matrix_right_part</code><span class="sig-paren">(</span><em><span class="n">mass_1</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">mass_2</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">epsilon</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrix.compute_enriched_mass_matrix_right_part" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Hansbo mass matrix for the right part
DDL are organized : 2 : N2d and 3: N1d
:param mass_1 : mass of the cracked cell
:param mass_2: mass of the element right on the right of the cracked cell
:param epsilon: relative position of the disc inside the cracked cell</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrix.get_mass_matrix_left">
<em class="property">abstract </em><code class="descname">get_mass_matrix_left</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrix.get_mass_matrix_left" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the part of mass matrix concerning the left part of the cracked cell</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrix.get_mass_matrix_right">
<em class="property">abstract </em><code class="descname">get_mass_matrix_right</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrix.get_mass_matrix_right" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the part of mass matrix concerning the right part of the cracked cell</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrix.inverse_enriched_mass_matrix_classic_dof">
<em class="property">property </em><code class="descname">inverse_enriched_mass_matrix_classic_dof</code><a class="headerlink" href="#mass_matrix.EnrichedMassMatrix.inverse_enriched_mass_matrix_classic_dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the inverse of the mass matrix for classical degrees of freedom
:return: the extraction of the inverse of the mass matrix for classical dof</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrix.inverse_enriched_mass_matrix_enriched_dof">
<em class="property">property </em><code class="descname">inverse_enriched_mass_matrix_enriched_dof</code><a class="headerlink" href="#mass_matrix.EnrichedMassMatrix.inverse_enriched_mass_matrix_enriched_dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the inverse of the mass matrix for enriched degrees of freedom
:return: extraction of the inverse of the mass matrix for enriched dof</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrix.print_enriched_mass_matrix">
<em class="property">abstract </em><code class="descname">print_enriched_mass_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrix.print_enriched_mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the mass matrix * (with aligned members)
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrix.rearrange_dof_in_inv_mass_matrix">
<em class="property">abstract </em><code class="descname">rearrange_dof_in_inv_mass_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrix.rearrange_dof_in_inv_mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Rearrange dof to easily compute the node velocity with classical and enriched dof separately</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="mass_matrix.EnrichedMassMatrixConsistent">
<em class="property">class </em><code class="descclassname">mass_matrix.</code><code class="descname">EnrichedMassMatrixConsistent</code><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixConsistent" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for the consistent enriched mass matrix</p>
<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixConsistent.assemble_enriched_mass_matrix">
<code class="descname">assemble_enriched_mass_matrix</code><span class="sig-paren">(</span><em><span class="o">*</span><span class="n">sub_matrix_names</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixConsistent.assemble_enriched_mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble and inverse the mass matrix after enrichment</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixConsistent.compute_enriched_mass_matrix_left_part">
<code class="descname">compute_enriched_mass_matrix_left_part</code><span class="sig-paren">(</span><em><span class="n">mass_0</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">mass_1</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">epsilon</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixConsistent.compute_enriched_mass_matrix_left_part" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Hansbo mass matrix for the left part
DDL are organized : 0 : N1g and 1 : N2g
:param mass_0: mass of the element right on the left of the cracked cell
:param mass_1 : mass of the cracked cell
:param epsilon: relative position of the disc inside the cracked cell</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixConsistent.compute_enriched_mass_matrix_right_part">
<code class="descname">compute_enriched_mass_matrix_right_part</code><span class="sig-paren">(</span><em><span class="n">mass_1</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">mass_2</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">epsilon</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixConsistent.compute_enriched_mass_matrix_right_part" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Hansbo mass matrix for the right part
DDL are organized : 2 : N2d and 3: N1d
:param mass_1 : mass of the cracked cell
:param mass_2: mass of the element right on the right of the cracked cell
:param epsilon: relative position of the disc inside the cracked cell</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixConsistent.get_mass_matrix_left">
<code class="descname">get_mass_matrix_left</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixConsistent.get_mass_matrix_left" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the part of mass matrix concerning the left part of the cracked cell</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixConsistent.get_mass_matrix_right">
<code class="descname">get_mass_matrix_right</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixConsistent.get_mass_matrix_right" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the part of mass matrix concerning the right part of the cracked cell</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixConsistent.inverse_enriched_mass_matrix_classic_dof">
<em class="property">property </em><code class="descname">inverse_enriched_mass_matrix_classic_dof</code><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixConsistent.inverse_enriched_mass_matrix_classic_dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the inverse of the mass matrix for classical degrees of freedom
:return: the extraction of the inverse of the mass matrix for classical dof</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixConsistent.inverse_enriched_mass_matrix_coupling_dof">
<em class="property">property </em><code class="descname">inverse_enriched_mass_matrix_coupling_dof</code><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixConsistent.inverse_enriched_mass_matrix_coupling_dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the inverse of the mass matrix for coupling between classical and enriched
degrees of freedom
:return: the coupling part of the inverse of the mass matrix</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixConsistent.inverse_enriched_mass_matrix_enriched_dof">
<em class="property">property </em><code class="descname">inverse_enriched_mass_matrix_enriched_dof</code><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixConsistent.inverse_enriched_mass_matrix_enriched_dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the inverse of the mass matrix for enriched degrees of freedom
:return: extraction of the inverse of the mass matrix for enriched dof</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixConsistent.print_enriched_mass_matrix">
<code class="descname">print_enriched_mass_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixConsistent.print_enriched_mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the mass matrix * (with aligned members)
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixConsistent.rearrange_dof_in_inv_mass_matrix">
<code class="descname">rearrange_dof_in_inv_mass_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixConsistent.rearrange_dof_in_inv_mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Rearrange dof to easily compute the node velocity with classical and enriched dof separately</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="mass_matrix.EnrichedMassMatrixLump">
<em class="property">class </em><code class="descclassname">mass_matrix.</code><code class="descname">EnrichedMassMatrixLump</code><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixLump" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for the lumped enriched mass matrix</p>
<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixLump.assemble_enriched_mass_matrix">
<code class="descname">assemble_enriched_mass_matrix</code><span class="sig-paren">(</span><em><span class="o">*</span><span class="n">sub_matrix_names</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixLump.assemble_enriched_mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble and inverse the mass matrix after enrichment</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixLump.compute_enriched_mass_matrix_left_part">
<em class="property">abstract </em><code class="descname">compute_enriched_mass_matrix_left_part</code><span class="sig-paren">(</span><em><span class="n">mass_0</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">mass_1</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">epsilon</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixLump.compute_enriched_mass_matrix_left_part" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Hansbo mass matrix for the left part
DDL are organized : 0 : N1g and 1 : N2g
:param mass_0: mass of the element right on the left of the cracked cell
:param mass_1 : mass of the cracked cell
:param epsilon: relative position of the disc inside the cracked cell</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixLump.compute_enriched_mass_matrix_right_part">
<em class="property">abstract </em><code class="descname">compute_enriched_mass_matrix_right_part</code><span class="sig-paren">(</span><em><span class="n">mass_1</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">mass_2</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">epsilon</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixLump.compute_enriched_mass_matrix_right_part" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Hansbo mass matrix for the right part
DDL are organized : 2 : N2d and 3: N1d
:param mass_1 : mass of the cracked cell
:param mass_2: mass of the element right on the right of the cracked cell
:param epsilon: relative position of the disc inside the cracked cell</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixLump.get_mass_matrix_left">
<code class="descname">get_mass_matrix_left</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; numpy.array<a class="headerlink" href="#mass_matrix.EnrichedMassMatrixLump.get_mass_matrix_left" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the part of mass matrix concerning the left part of the cracked cell</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixLump.get_mass_matrix_right">
<code class="descname">get_mass_matrix_right</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; numpy.array<a class="headerlink" href="#mass_matrix.EnrichedMassMatrixLump.get_mass_matrix_right" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the part of mass matrix concerning the right part of the cracked cell</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixLump.inverse_enriched_mass_matrix_classic_dof">
<em class="property">property </em><code class="descname">inverse_enriched_mass_matrix_classic_dof</code><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixLump.inverse_enriched_mass_matrix_classic_dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the inverse of the mass matrix for classical degrees of freedom
:return: the extraction of the inverse of the mass matrix for classical dof</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixLump.inverse_enriched_mass_matrix_enriched_dof">
<em class="property">property </em><code class="descname">inverse_enriched_mass_matrix_enriched_dof</code><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixLump.inverse_enriched_mass_matrix_enriched_dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the inverse of the mass matrix for enriched degrees of freedom
:return: extraction of the inverse of the mass matrix for enriched dof</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixLump.print_enriched_mass_matrix">
<code class="descname">print_enriched_mass_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixLump.print_enriched_mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the mass matrix * (with aligned members)</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixLump.rearrange_dof_in_inv_mass_matrix">
<code class="descname">rearrange_dof_in_inv_mass_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixLump.rearrange_dof_in_inv_mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Rearrange dof to easily compute the node velocity with classical and enriched dof
separately</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="mass_matrix.EnrichedMassMatrixLumpMenouillard">
<em class="property">class </em><code class="descclassname">mass_matrix.</code><code class="descname">EnrichedMassMatrixLumpMenouillard</code><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixLumpMenouillard" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for the lumped enriched mass matrix for Menouillard lumping</p>
<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixLumpMenouillard.compute_enriched_mass_matrix_left_part">
<code class="descname">compute_enriched_mass_matrix_left_part</code><span class="sig-paren">(</span><em><span class="n">mass_0</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">mass_1</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">epsilon</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixLumpMenouillard.compute_enriched_mass_matrix_left_part" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Hansbo mass matrix for the left part
DDL are organized : 0 : N1g and 1 : N2g
:param mass_0: mass of the element right on the left of the cracked cell
:param mass_1 : mass of the cracked cell
:param epsilon: relative position of the disc inside the cracked cell</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixLumpMenouillard.compute_enriched_mass_matrix_right_part">
<code class="descname">compute_enriched_mass_matrix_right_part</code><span class="sig-paren">(</span><em><span class="n">mass_1</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">mass_2</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">epsilon</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixLumpMenouillard.compute_enriched_mass_matrix_right_part" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Hansbo mass matrix for the right part
DDL are organized : 2 : N2d and 3: N1d
:param mass_1 : mass of the cracked cell
:param mass_2: mass of the element right on the right of the cracked cell
:param epsilon: relative position of the disc inside the cracked cell</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="mass_matrix.EnrichedMassMatrixLumpSum">
<em class="property">class </em><code class="descclassname">mass_matrix.</code><code class="descname">EnrichedMassMatrixLumpSum</code><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixLumpSum" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for the enriched mass matrix lumped with sum of lines of the consistent enriched
mass matrix</p>
<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixLumpSum.compute_enriched_mass_matrix_left_part">
<code class="descname">compute_enriched_mass_matrix_left_part</code><span class="sig-paren">(</span><em><span class="n">mass_0</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">mass_1</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">epsilon</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixLumpSum.compute_enriched_mass_matrix_left_part" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Hansbo mass matrix for the left part
DDL are organized : 0 : N1g and 1 : N2g
:param mass_0: mass of the element right on the left of the cracked cell
:param mass_1 : mass of the cracked cell
:param epsilon: relative position of the disc inside the cracked cell</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.EnrichedMassMatrixLumpSum.compute_enriched_mass_matrix_right_part">
<code class="descname">compute_enriched_mass_matrix_right_part</code><span class="sig-paren">(</span><em><span class="n">mass_1</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">mass_2</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">epsilon</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.EnrichedMassMatrixLumpSum.compute_enriched_mass_matrix_right_part" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Hansbo mass matrix for the right part
DDL are organized : 2 : N2d and 3: N1d
:param mass_1 : mass of the cracked cell
:param mass_2: mass of the element right on the right of the cracked cell
:param epsilon: relative position of the disc inside the cracked cell</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="mass_matrix.OneDimensionMassMatrix">
<em class="property">class </em><code class="descclassname">mass_matrix.</code><code class="descname">OneDimensionMassMatrix</code><span class="sig-paren">(</span><em><span class="n">number_of_nodes</span></em>, <em><span class="n">consistent_matrix_on_last_cells</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.OneDimensionMassMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for 1d mass matrix</p>
<dl class="py method">
<dt id="mass_matrix.OneDimensionMassMatrix.compute_correction_mass_matrix_for_cell_500">
<code class="descname">compute_correction_mass_matrix_for_cell_500</code><span class="sig-paren">(</span><em><span class="n">cell_mass_vector</span></em>, <em><span class="n">mask_node</span></em>, <em><span class="n">topologie</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.OneDimensionMassMatrix.compute_correction_mass_matrix_for_cell_500" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the exact form of mass matrix (classical) , no lumping
:param cell_mass_vector: vector of cells mass
:param mask_node: id of cell to be considered
:param topologie : topology</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.OneDimensionMassMatrix.compute_mass_matrix">
<code class="descname">compute_mass_matrix</code><span class="sig-paren">(</span><em><span class="n">topology</span></em>, <em><span class="n">cell_mass_vector</span></em>, <em><span class="n">node_number_by_cell_vector</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.OneDimensionMassMatrix.compute_mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mass matrix and its inverse according to Wilkins method</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first last simple">
<li><strong>topology</strong> – topology of the simulation</li>
<li><strong>cell_mass_vector</strong> – cells mass vector</li>
<li><strong>node_number_by_cell_vector</strong> – number of nodes per cell (vector)</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.OneDimensionMassMatrix.inverse_correction_mass_matrix">
<em class="property">property </em><code class="descname">inverse_correction_mass_matrix</code><a class="headerlink" href="#mass_matrix.OneDimensionMassMatrix.inverse_correction_mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the inverse of the exact mass matrix</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">the inverse of the exact mass matrix</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.OneDimensionMassMatrix.inverse_mass_matrix">
<em class="property">property </em><code class="descname">inverse_mass_matrix</code><a class="headerlink" href="#mass_matrix.OneDimensionMassMatrix.inverse_mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the inverse of the mass matrix</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">the inverse of the mass matrix</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.OneDimensionMassMatrix.mass_matrix">
<em class="property">property </em><code class="descname">mass_matrix</code><a class="headerlink" href="#mass_matrix.OneDimensionMassMatrix.mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on _mass_matrix</p>
</dd></dl>

<dl class="py method">
<dt id="mass_matrix.OneDimensionMassMatrix.mass_matrix_correction">
<em class="property">property </em><code class="descname">mass_matrix_correction</code><a class="headerlink" href="#mass_matrix.OneDimensionMassMatrix.mass_matrix_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on _mass_matrix</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="mass_matrix.SymNDArray">
<em class="property">class </em><code class="descclassname">mass_matrix.</code><code class="descname">SymNDArray</code><a class="headerlink" href="#mass_matrix.SymNDArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Une classe pour les matrices symétriques</p>
</dd></dl>

<dl class="py function">
<dt id="mass_matrix.compute_wilkins_mass_matrix">
<code class="descclassname">mass_matrix.</code><code class="descname">compute_wilkins_mass_matrix</code><span class="sig-paren">(</span><em><span class="n">topology</span></em>, <em><span class="n">cell_mass_vector</span></em>, <em><span class="n">node_number_by_cell_vector</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.compute_wilkins_mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute nodal mass by averaging the mass of neighbouring cells (Wilkins method)</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first last simple">
<li><strong>topology</strong> (<a class="reference internal" href="#mesh.Topology" title="mesh.Topology"><em>Topology</em></a>) – topology of the simulation</li>
<li><strong>cell_mass_vector</strong> (<em>numpy.array</em><em>(</em><em>[</em><em>nbr_of_nodes</em><em>, </em><em>1</em><em>]</em><em>, </em><em>dtype=np.float64</em><em>, </em><em>order='C'</em><em>)</em>) – cells mass vector</li>
<li><strong>node_number_by_cell_vector</strong> (<em>numpy.array</em><em>(</em><em>[</em><em>nbr_of_nodes</em><em>, </em><em>1</em><em>]</em><em>, </em><em>dtype=np.int64</em><em>, </em><em>order='C'</em><em>)</em>) – number of nodes per cell (vector)</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mass_matrix.multiplication_masse">
<code class="descclassname">mass_matrix.</code><code class="descname">multiplication_masse</code><span class="sig-paren">(</span><em><span class="n">matrix</span></em>, <em><span class="n">vector</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.multiplication_masse" title="Permalink to this definition">¶</a></dt>
<dd><p>Fonction pour faire le produit matriciel matrice * vecteur adapté pour la matrice masse sous
forme de vecteur
:param matrix : matrix (array multiD)
:param vector: vector (array 1D)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrice</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vecteur</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">4.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multiplication_masse</span><span class="p">(</span><span class="n">matrice</span><span class="p">,</span> <span class="n">vecteur</span><span class="p">)</span>
<span class="go">array([ 1.,  1.,  1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrice_bis</span> <span class="o">=</span>     <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vecteur_bis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">4.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multiplication_masse</span><span class="p">(</span><span class="n">matrice_bis</span><span class="p">,</span> <span class="n">vecteur_bis</span><span class="p">)</span>
<span class="go">array([ 3.75 ,  3.875,  3.   ,  3.75 ])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="mass_matrix.inverse_masse">
<code class="descclassname">mass_matrix.</code><code class="descname">inverse_masse</code><span class="sig-paren">(</span><em><span class="n">matrix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.inverse_masse" title="Permalink to this definition">¶</a></dt>
<dd><p>MassMatrix de type MassMatrix
Fonction pour faire inverse la matrice masse, qu’elle soit sous forme de vecteur ou de matrice
:param matrix: matrix to inverse</p>
</dd></dl>

<dl class="py function">
<dt id="mass_matrix.lump_matrix">
<code class="descclassname">mass_matrix.</code><code class="descname">lump_matrix</code><span class="sig-paren">(</span><em><span class="n">matrix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mass_matrix.lump_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Condense la matrice de masse avec la méthode de Menouillard
(on somme sur toute la ligne pour obtenir une matrice diagonale)
:param matrix: matrix to lump</p>
</dd></dl>

</div>
<div class="section" id="module-mesh">
<span id="mesh"></span><h2>Mesh<a class="headerlink" href="#module-mesh" title="Permalink to this headline">¶</a></h2>
<p>Package for mesh modules</p>
<dl class="py class">
<dt id="mesh.Mesh1dEnriched">
<em class="property">class </em><code class="descclassname">mesh.</code><code class="descname">Mesh1dEnriched</code><span class="sig-paren">(</span><em><span class="n">initial_coordinates</span></em>, <em><span class="n">initial_velocities</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched" title="Permalink to this definition">¶</a></dt>
<dd><p>This class defines a one dimensional mesh with potential enrichment</p>
<dl class="py method">
<dt id="mesh.Mesh1dEnriched.apply_contact_correction">
<code class="descname">apply_contact_correction</code><span class="sig-paren">(</span><em><span class="n">delta_t</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.apply_contact_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the contact force to be applied to ensure non penetration of the
discontinuities boundaries
:param delta_t : time step</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.apply_elasticity">
<code class="descname">apply_elasticity</code><span class="sig-paren">(</span><em><span class="n">delta_t</span></em>, <em><span class="n">shear_modulus_model</span></em>, <em><span class="n">mask_material</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.apply_elasticity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the deviatoric part of stress tensor
:param delta_t : float, time step staggered
:param shear_modulus_model: model to compute the shear modulus
:param mask_material: array of bool to select cells of interest</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.apply_plasticity">
<code class="descname">apply_plasticity</code><span class="sig-paren">(</span><em><span class="n">delta_t</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">yield_stress_model</span></em>, <em><span class="n">plasticity_criterion</span></em>, <em><span class="n">mask_mesh</span><span class="p">:</span> <span class="n">numpy.array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.apply_plasticity" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply plasticity treatment if criterion is activated :
- compute yield stress
- tests plasticity criterion
- compute plastic strain rate for plastic cells
:param delta_t : time step
:param yield_stress_model: model to compute the yield stress
:param plasticity_criterion: model for the plasticity criterion
:param mask_mesh : mask cells in projectile or target</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.apply_pressure">
<code class="descname">apply_pressure</code><span class="sig-paren">(</span><em><span class="n">surface</span></em>, <em><span class="n">pressure</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.apply_pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a given pressure on left or right boundary
:var surface: name of the surface where pressure has to be imposed
:var pressure: value of the pressure to impose
:type surface: str (‘left’ | ‘right’)
:type pressure: float</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.apply_rupture_treatment">
<code class="descname">apply_rupture_treatment</code><span class="sig-paren">(</span><em><span class="n">treatment</span></em>, <em><span class="n">time</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.apply_rupture_treatment" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the rupture treatment on the cells enforcing the rupture criterion
:var treatment: rupture treatment
:type treatment: RuptureTreatment
:param time : simulation time</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.apply_velocity_boundary_condition">
<code class="descname">apply_velocity_boundary_condition</code><span class="sig-paren">(</span><em><span class="n">surface</span></em>, <em><span class="n">velocity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.apply_velocity_boundary_condition" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a given velocity on left or right boundary</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.artificial_viscosity_field">
<em class="property">property </em><code class="descname">artificial_viscosity_field</code><a class="headerlink" href="#mesh.Mesh1dEnriched.artificial_viscosity_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Artificial viscosity field</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.assemble_complete_stress_tensor">
<code class="descname">assemble_complete_stress_tensor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.assemble_complete_stress_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Assembling pressure and stress deviator</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.cells_coordinates">
<em class="property">property </em><code class="descname">cells_coordinates</code><a class="headerlink" href="#mesh.Mesh1dEnriched.cells_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Cells coordinates (coordinates of cells centers)</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.compute_cells_masses">
<code class="descname">compute_cells_masses</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.compute_cells_masses" title="Permalink to this definition">¶</a></dt>
<dd><p>Cell mass computation</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.compute_cells_sizes">
<code class="descname">compute_cells_sizes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.compute_cells_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of cells sizes at t</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.compute_new_cells_densities">
<code class="descname">compute_new_cells_densities</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.compute_new_cells_densities" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of cells densities at t+dt</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.compute_new_cells_pressures">
<code class="descname">compute_new_cells_pressures</code><span class="sig-paren">(</span><em><span class="n">delta_t</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.compute_new_cells_pressures" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of cells pressure at t+dt
:var delta_t: time step</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.compute_new_cells_pseudo_viscosity">
<code class="descname">compute_new_cells_pseudo_viscosity</code><span class="sig-paren">(</span><em><span class="n">delta_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.compute_new_cells_pseudo_viscosity" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of cells artificial viscosity at t+dt
:var delta_t: time step
:type delta_t: float</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.compute_new_cells_sizes">
<code class="descname">compute_new_cells_sizes</code><span class="sig-paren">(</span><em><span class="n">delta_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.compute_new_cells_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of cells sizes at t+dt</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.compute_new_cohesive_forces">
<code class="descname">compute_new_cohesive_forces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.compute_new_cohesive_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of cohesive forces at t+dt</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.compute_new_nodes_coordinates">
<code class="descname">compute_new_nodes_coordinates</code><span class="sig-paren">(</span><em><span class="n">delta_t</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.compute_new_nodes_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of nodes coordinates at t+dt
:param delta_t: time step</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.compute_new_nodes_forces">
<code class="descname">compute_new_nodes_forces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.compute_new_nodes_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of nodes forces at t+dt</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.compute_new_nodes_velocities">
<code class="descname">compute_new_nodes_velocities</code><span class="sig-paren">(</span><em><span class="n">delta_t</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.compute_new_nodes_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of nodes velocities at t+dt
:var delta_t: time step</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.compute_new_time_step">
<code class="descname">compute_new_time_step</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.compute_new_time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Computation of new time step</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.compute_nodes_masses">
<code class="descname">compute_nodes_masses</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.compute_nodes_masses" title="Permalink to this definition">¶</a></dt>
<dd><p>Nodal mass computation</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.density_field">
<em class="property">property </em><code class="descname">density_field</code><a class="headerlink" href="#mesh.Mesh1dEnriched.density_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Density field</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.deviatoric_stress_field">
<em class="property">property </em><code class="descname">deviatoric_stress_field</code><a class="headerlink" href="#mesh.Mesh1dEnriched.deviatoric_stress_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Deviatoric stress field</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.energy_field">
<em class="property">property </em><code class="descname">energy_field</code><a class="headerlink" href="#mesh.Mesh1dEnriched.energy_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal energy field</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.get_discontinuity_list">
<em class="property">static </em><code class="descname">get_discontinuity_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.get_discontinuity_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the list of existing discontinuities
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.get_ruptured_cells">
<code class="descname">get_ruptured_cells</code><span class="sig-paren">(</span><em><span class="n">rupture_criterion</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.get_ruptured_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the cells where the rupture criterion is checked and store them
:var rupture_criterion: rupture criterion
:type rupture_criterion: RuptureCriterion</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.increment">
<code class="descname">increment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Mesh1dEnriched.increment" title="Permalink to this definition">¶</a></dt>
<dd><p>Moving to next time step</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.nodes_coordinates">
<em class="property">property </em><code class="descname">nodes_coordinates</code><a class="headerlink" href="#mesh.Mesh1dEnriched.nodes_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Nodes coordinates</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.pressure_field">
<em class="property">property </em><code class="descname">pressure_field</code><a class="headerlink" href="#mesh.Mesh1dEnriched.pressure_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Pressure field</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.stress_xx_field">
<em class="property">property </em><code class="descname">stress_xx_field</code><a class="headerlink" href="#mesh.Mesh1dEnriched.stress_xx_field" title="Permalink to this definition">¶</a></dt>
<dd><p>First component of the Cauchy stress tensor</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.topology">
<em class="property">property </em><code class="descname">topology</code><a class="headerlink" href="#mesh.Mesh1dEnriched.topology" title="Permalink to this definition">¶</a></dt>
<dd><p>Retourne l’objet de topologie (pour qu’il soit accesible pour les tests unitaires)</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Mesh1dEnriched.velocity_field">
<em class="property">property </em><code class="descname">velocity_field</code><a class="headerlink" href="#mesh.Mesh1dEnriched.velocity_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Node velocity field</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="mesh.Topology">
<em class="property">class </em><code class="descclassname">mesh.</code><code class="descname">Topology</code><span class="sig-paren">(</span><em><span class="n">nbr_of_nodes</span></em>, <em><span class="n">nbr_of_cells</span></em>, <em><span class="n">dim</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Topology" title="Permalink to this definition">¶</a></dt>
<dd><p>Une classe gï¿½rant la topologie et les connectivitï¿½s d’un maillage</p>
<dl class="py method">
<dt id="mesh.Topology.add_cell_in_contact_with_node">
<code class="descname">add_cell_in_contact_with_node</code><span class="sig-paren">(</span><em><span class="n">ind_node</span></em>, <em><span class="n">ind_cell</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Topology.add_cell_in_contact_with_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Ajoute l’indice, ‘ind_cell’, de la maille Ã&nbsp; la liste des mailles en contact
avec le noeud d’indice ‘ind_node’</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Topology.cells_in_contact_with_node">
<em class="property">property </em><code class="descname">cells_in_contact_with_node</code><a class="headerlink" href="#mesh.Topology.cells_in_contact_with_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the array for cells &lt;-&gt; nodes connectivity</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Topology.dimension">
<em class="property">property </em><code class="descname">dimension</code><a class="headerlink" href="#mesh.Topology.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension of the mesh</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Topology.get_cells_in_contact_with_node">
<code class="descname">get_cells_in_contact_with_node</code><span class="sig-paren">(</span><em><span class="n">ind_node</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Topology.get_cells_in_contact_with_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Renvoie un tableau des mailles en contact avec le noeud</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>ind_node</strong> (<em>int</em>) – indice du noeud dont on veut connaitre les mailles connexes</dd>
<dt class="field-name">Returns</dt><dd class="field-body">un tableau des mailles en contact avec le noeud</dd>
<dt class="field-name">Return type</dt><dd class="field-body">numpy.array</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mesh.Topology.get_nodes_belonging_to_cell">
<code class="descname">get_nodes_belonging_to_cell</code><span class="sig-paren">(</span><em><span class="n">ind_cell</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Topology.get_nodes_belonging_to_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Renvoie un tableau des noeuds appartenant ï¿½ la maille
:param ind_cell: indice de la maille dont on veut connaitre les noeuds
:return: un tableau des noeuds appartenant ï¿½ la maille
:type ind_cell: int
:rtype: numpy.array</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Topology.nodes_belonging_to_cell">
<em class="property">property </em><code class="descname">nodes_belonging_to_cell</code><a class="headerlink" href="#mesh.Topology.nodes_belonging_to_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the array for nodes &lt;-&gt; cells connectivity</p>
</dd></dl>

<dl class="py method">
<dt id="mesh.Topology.set_nodes_belonging_to_cell">
<code class="descname">set_nodes_belonging_to_cell</code><span class="sig-paren">(</span><em><span class="n">ind_cell</span></em>, <em><span class="n">ind_node_list</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Topology.set_nodes_belonging_to_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Attribue la liste des indices des noeuds, ‘nodes_list’
appartenant ï¿½ la maille d’indice ‘ind_cell’
:param ind_cell: indice de la maille ï¿½ laquelle attribuer les indices de noeuds
: ind_node_list: indices des noeuds appartenant ï¿½ la cellule d’indice ind_cell
:type ind_cell: int
:type ind_node_list: list</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="mesh.Topology1D">
<em class="property">class </em><code class="descclassname">mesh.</code><code class="descname">Topology1D</code><span class="sig-paren">(</span><em><span class="n">nbr_of_nodes</span></em>, <em><span class="n">nbr_of_cells</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Topology1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Spï¿½cialisation 1D de topology</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_topo</span> <span class="o">=</span> <span class="n">Topology1D</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_topo</span><span class="o">.</span><span class="n">get_cells_in_contact_with_node</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ -1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_topo</span><span class="o">.</span><span class="n">get_cells_in_contact_with_node</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([4, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_topo</span><span class="o">.</span><span class="n">get_nodes_belonging_to_cell</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="go">array([ 9, 10])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_topo</span><span class="o">.</span><span class="n">get_cells_in_contact_with_node</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_topo</span><span class="o">.</span><span class="n">cells_in_contact_with_node</span><span class="p">[:]</span>
<span class="go">array([[ -1, 0],</span>
<span class="go">       [ 0,  1],</span>
<span class="go">       [ 1,  2],</span>
<span class="go">       [ 2,  3],</span>
<span class="go">       [ 3,  4],</span>
<span class="go">       [ 4,  5],</span>
<span class="go">       [ 5,  6],</span>
<span class="go">       [ 6,  7],</span>
<span class="go">       [ 7,  8],</span>
<span class="go">       [ 8,  9],</span>
<span class="go">       [ 9, -1]])</span>
</pre></div>
</div>
<dl class="py method">
<dt id="mesh.Topology1D.add_cell_in_contact_with_node">
<code class="descname">add_cell_in_contact_with_node</code><span class="sig-paren">(</span><em><span class="n">ind_node</span></em>, <em><span class="n">ind_cell</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mesh.Topology1D.add_cell_in_contact_with_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Ajoute l’indice, ‘ind_cell’, de la maille ï¿½ la liste des mailles en contact
avec le noeud d’indice ‘ind_node’</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-node">
<span id="nodes"></span><h2>Nodes<a class="headerlink" href="#module-node" title="Permalink to this headline">¶</a></h2>
<p>Package for nodes module</p>
<dl class="py class">
<dt id="node.Node">
<em class="property">class </em><code class="descclassname">node.</code><code class="descname">Node</code><span class="sig-paren">(</span><em><span class="n">nbr_of_nodes</span></em>, <em><span class="n">position_initiale</span></em>, <em><span class="n">dim</span><span class="o">=</span><span class="default_value">1</span></em>, <em><span class="n">vitesse_initiale</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Un objet Node représente l’ensemble des noeuds du maillages. Ses différents membres sont
essentiellement des vecteurs de nbr_of_nodes lignes. Plusieurs colonnes peuvent être
présentes selon la dimension du problème à traiter.</p>
<p>L’organisation en mémoire est comme en C/C++ c’est à dire ‘row wise’. C’est pour cette raison
que les lignes de chacun des vecteurs représentent les noeuds. Ce faisant on a par exemple
tous les X des noeuds contigus en mêmoire. (vectorisation, localisation spatiale)</p>
<dl class="py method">
<dt id="node.Node.compute_new_coodinates">
<code class="descname">compute_new_coodinates</code><span class="sig-paren">(</span><em><span class="n">mask</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em><span class="n">delta_t</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.Node.compute_new_coodinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Calcul de la coordonnée au temps t+dt
:param mask : mask to select some specific nodes
:param delta_t: time step</p>
</dd></dl>

<dl class="py method">
<dt id="node.Node.compute_new_force">
<em class="property">abstract </em><code class="descname">compute_new_force</code><span class="sig-paren">(</span><em><span class="o">*</span><span class="n">args</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.Node.compute_new_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Calcul de la force agissant sur le noeud</p>
</dd></dl>

<dl class="py method">
<dt id="node.Node.compute_new_velocity">
<em class="property">abstract </em><code class="descname">compute_new_velocity</code><span class="sig-paren">(</span><em><span class="n">delta_t</span></em>, <em><span class="n">mask</span></em>, <em><span class="n">matrice_masse</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.Node.compute_new_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calcul de la vitesse au demi pas de temps supérieur</p>
</dd></dl>

<dl class="py method">
<dt id="node.Node.dimension">
<em class="property">property </em><code class="descname">dimension</code><a class="headerlink" href="#node.Node.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension du problème</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">dimension du problème</dd>
<dt class="field-name">Return type</dt><dd class="field-body">int</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="node.Node.enriched">
<em class="property">property </em><code class="descname">enriched</code><a class="headerlink" href="#node.Node.enriched" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of the status of all nodes
False = classical node
True = enriched node
:return:  numpy.array([nbr_of_nodes], dtype=bool)</p>
</dd></dl>

<dl class="py method">
<dt id="node.Node.force">
<em class="property">property </em><code class="descname">force</code><a class="headerlink" href="#node.Node.force" title="Permalink to this definition">¶</a></dt>
<dd><p>Forces nodales</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">vecteur des forces nodales</dd>
<dt class="field-name">Return type</dt><dd class="field-body">numpy.array([nbr_of_nodes, 1], dtype=np.float64, order=’C’)</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="node.Node.increment">
<code class="descname">increment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#node.Node.increment" title="Permalink to this definition">¶</a></dt>
<dd><p>Mise à jour de la vitesse et de la coordonnée des noeuds
pour passer au pas de temps suivant.</p>
</dd></dl>

<dl class="py method">
<dt id="node.Node.infos">
<code class="descname">infos</code><span class="sig-paren">(</span><em><span class="n">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.Node.infos" title="Permalink to this definition">¶</a></dt>
<dd><p>Affichage des informations concernant le noeud d’indice index</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>index</strong> (<em>int</em>) – indice du noeud à afficher</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="node.Node.masse">
<em class="property">property </em><code class="descname">masse</code><a class="headerlink" href="#node.Node.masse" title="Permalink to this definition">¶</a></dt>
<dd><p>Masses nodales</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">vecteur des masses nodales</dd>
<dt class="field-name">Return type</dt><dd class="field-body">numpy.array([nbr_of_nodes, 1], dtype=np.float64, order=’C’)</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="node.Node.number_of_nodes">
<em class="property">property </em><code class="descname">number_of_nodes</code><a class="headerlink" href="#node.Node.number_of_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Nombre de noeuds du problème</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">dimension du problème</dd>
<dt class="field-name">Return type</dt><dd class="field-body">int</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="node.Node.umundemi">
<em class="property">property </em><code class="descname">umundemi</code><a class="headerlink" href="#node.Node.umundemi" title="Permalink to this definition">¶</a></dt>
<dd><p>Vitesses au demi pas de temps précédent</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">vitesses des noeuds au demi pas de temps précédent</dd>
<dt class="field-name">Return type</dt><dd class="field-body">numpy.array([nbr_of_nodes, dim], dtype=np.float64, order=’C’)</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="node.Node.upundemi">
<em class="property">property </em><code class="descname">upundemi</code><a class="headerlink" href="#node.Node.upundemi" title="Permalink to this definition">¶</a></dt>
<dd><p>Vitesses au demi pas de temps suivant</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">vitesses des noeuds au demi pas de temps suivant</dd>
<dt class="field-name">Return type</dt><dd class="field-body">numpy.array([nbr_of_nodes, dim], dtype=np.float64, order=’C’)</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="node.Node.xt">
<em class="property">property </em><code class="descname">xt</code><a class="headerlink" href="#node.Node.xt" title="Permalink to this definition">¶</a></dt>
<dd><p>Positions des noeuds au temps t</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">positions des noeuds au temps t</dd>
<dt class="field-name">Return type</dt><dd class="field-body">numpy.array([nbr_of_nodes, dim], dtype=np.float64, order=’C’)</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="node.Node.xtpdt">
<em class="property">property </em><code class="descname">xtpdt</code><a class="headerlink" href="#node.Node.xtpdt" title="Permalink to this definition">¶</a></dt>
<dd><p>Positions des noeuds au temps t + dt</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">positions des noeuds au temps t + dt</dd>
<dt class="field-name">Return type</dt><dd class="field-body">numpy.array([nbr_of_nodes, dim], dtype=np.float64, order=’C’)</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="node.OneDimensionNode">
<em class="property">class </em><code class="descclassname">node.</code><code class="descname">OneDimensionNode</code><span class="sig-paren">(</span><em><span class="n">nbr_of_nodes</span></em>, <em><span class="n">poz_init</span></em>, <em><span class="n">vit_init</span></em>, <em><span class="n">section</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Un objet Node1d reprï¿½sente l’ensemble des noeuds 1d du maillage</p>
<dl class="py method">
<dt id="node.OneDimensionNode.apply_correction_reference_bar">
<code class="descname">apply_correction_reference_bar</code><span class="sig-paren">(</span><em><span class="n">delta_t</span></em>, <em><span class="n">inv_complete_mass_matrix</span></em>, <em><span class="n">inv_wilkins_mass_matrix</span></em>, <em><span class="n">mask</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionNode.apply_correction_reference_bar" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a correction on velocity field to compute velocity from exact(non lumped)
mass matrix for elements in mask</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionNode.apply_pressure">
<code class="descname">apply_pressure</code><span class="sig-paren">(</span><em><span class="n">ind_node</span></em>, <em><span class="n">pressure</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionNode.apply_pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Appliquer une pressure sur le noeud d’indice “ind_node”
:param ind_node: indice du noeud sur lequel appliquer la pressure
:param pressure: pressure ï¿½ appliquer
:type ind_node: int
:type pressure: float</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionNode.apply_velocity_boundary_coundition">
<code class="descname">apply_velocity_boundary_coundition</code><span class="sig-paren">(</span><em><span class="n">ind_node</span></em>, <em><span class="n">velocity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionNode.apply_velocity_boundary_coundition" title="Permalink to this definition">¶</a></dt>
<dd><p>Appliquer une CL en vitesse sur le noeud ind_node
:param ind_node:
:param velocity:
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionNode.classical">
<em class="property">property </em><code class="descname">classical</code><a class="headerlink" href="#node.OneDimensionNode.classical" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">boolean mask indicating which nodes are classical</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionNode.compute_complete_velocity_field">
<code class="descname">compute_complete_velocity_field</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionNode.compute_complete_velocity_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Calcul du champ de vitesse vraie</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionNode.compute_new_force">
<code class="descname">compute_new_force</code><span class="sig-paren">(</span><em><span class="n">topologie</span></em>, <em><span class="n">contrainte</span></em>, <em><span class="n">classical_cell_mask</span><span class="p">:</span> <span class="n">numpy.array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionNode.compute_new_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Calcul des forces agissant sur les noeuds
:param topologie: topologie du calcul
:param contrainte : tenseur des contriante de cauchy sigma xx
:param classical_cell_mask: masks of the classical cells
:type topologie: Topology
:type contrainte: numpy.array([nbr_of_node-1, 1], dtype=np.float64, order=’C’)</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionNode.compute_new_velocity">
<code class="descname">compute_new_velocity</code><span class="sig-paren">(</span><em><span class="n">delta_t</span></em>, <em><span class="n">mask</span></em>, <em><span class="n">matrice_masse</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionNode.compute_new_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calcul de la vitesse au demi pas de temps supï¿½rieur
:param delta_t: pas de temps
:type delta_t: float
:param mask : noeuds sï¿½lectionnï¿½s pour calculer avec cette mï¿½thode</p>
<blockquote>
<div>(typiquement : OneDimensionEnrichedNode.classical / .enriched )
s’applique sur les degrï¿½s de libertï¿½ classiques des noeuds classiques ou enrichis
ne prend pas en compte le couplage entre degrï¿½s de libertï¿½ enrichis/classiques</div></blockquote>
<p>:type mask : tableau de boolï¿½ens
:param matrice_masse : inverse de la matrice de masse</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionNode.enrichment_not_concerned">
<em class="property">property </em><code class="descname">enrichment_not_concerned</code><a class="headerlink" href="#node.OneDimensionNode.enrichment_not_concerned" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">boolean mask indicating which nodes are concerned by enrichment</dd>
</dl>
<p>(a node is concerned by enrichment if one of his connected cell is enriched,
ie if its evolution is modified by enrichment)</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionNode.infos">
<code class="descname">infos</code><span class="sig-paren">(</span><em><span class="n">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionNode.infos" title="Permalink to this definition">¶</a></dt>
<dd><p>Affichage des informations concernant le noeud d’indice index</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>index</strong> (<em>int</em>) – indice du noeud ï¿½ afficher</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionNode.section">
<em class="property">property </em><code class="descname">section</code><a class="headerlink" href="#node.OneDimensionNode.section" title="Permalink to this definition">¶</a></dt>
<dd><p>Surface associï¿½e au noeud</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionNode.velocity_field">
<em class="property">property </em><code class="descname">velocity_field</code><a class="headerlink" href="#node.OneDimensionNode.velocity_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Champ de vitesse vraie</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="node.OneDimensionHansboEnrichedNode">
<em class="property">class </em><code class="descclassname">node.</code><code class="descname">OneDimensionHansboEnrichedNode</code><span class="sig-paren">(</span><em><span class="n">nbr_of_nodes</span><span class="p">:</span> <span class="n">int</span></em>, <em><span class="n">initial_positions</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em><span class="n">initial_velocities</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em><span class="n">section</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionHansboEnrichedNode" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for the enriched nodes with Hansbo enrichment</p>
<dl class="py method">
<dt id="node.OneDimensionHansboEnrichedNode.apply_force_on_discontinuity_boundaries">
<code class="descname">apply_force_on_discontinuity_boundaries</code><span class="sig-paren">(</span><em><span class="n">disc</span><span class="p">:</span> <span class="n">xfv.src.discontinuity.discontinuity.Discontinuity</span></em>, <em><span class="n">stress</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionHansboEnrichedNode.apply_force_on_discontinuity_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Transport the force to apply on discontinuity boundaries on the classical and enriched nodes
:param disc: current discontinuity
:param stress: value of the force to apply
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionHansboEnrichedNode.classical">
<em class="property">property </em><code class="descname">classical</code><a class="headerlink" href="#node.OneDimensionHansboEnrichedNode.classical" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">boolean mask indicating which nodes are classical</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionHansboEnrichedNode.compute_additional_dof_new_velocity">
<code class="descname">compute_additional_dof_new_velocity</code><span class="sig-paren">(</span><em><span class="n">delta_t</span></em>, <em><span class="n">inv_matrice_masse</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionHansboEnrichedNode.compute_additional_dof_new_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the new velocity enriched degree of freedom
:param delta_t: float, time step
:param inv_matrice_masse: inverse of the mass matrix</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionHansboEnrichedNode.compute_complete_velocity_field">
<code class="descname">compute_complete_velocity_field</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionHansboEnrichedNode.compute_complete_velocity_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the true field of node velocity</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionHansboEnrichedNode.compute_enriched_nodes_cohesive_forces">
<code class="descname">compute_enriched_nodes_cohesive_forces</code><span class="sig-paren">(</span><em><span class="n">cohesive_model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionHansboEnrichedNode.compute_enriched_nodes_cohesive_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cohesive forces for the enriched nodes
:param cohesive_model : cohesive model</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionHansboEnrichedNode.compute_enriched_nodes_new_force">
<code class="descname">compute_enriched_nodes_new_force</code><span class="sig-paren">(</span><em><span class="n">contrainte_xx</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em><span class="n">enr_contrainte_xx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionHansboEnrichedNode.compute_enriched_nodes_new_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the enriched force on enriched nodes and apply correction for classical
force on enriched nodes (classical ddl)
:param contrainte_xx : vecteur contrainte xx, array de taille (nb_cell, 1)
:param enr_contrainte_xx : vecteur contrainte xx enrichie, array de taille (nb_cell, 1)</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionHansboEnrichedNode.coupled_enrichment_terms_compute_new_velocity">
<code class="descname">coupled_enrichment_terms_compute_new_velocity</code><span class="sig-paren">(</span><em><span class="n">delta_t</span></em>, <em><span class="n">inv_matrix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionHansboEnrichedNode.coupled_enrichment_terms_compute_new_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the coupled terms between classical and enriched dof due to non diagonal
complete mass matrix. Takes into account nodes concerned by enrichment and
not only the enriched nodes
:param delta_t: time step
:param inv_matrix : inverse of the mass matrix (coupling classic / enr ddl part)</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionHansboEnrichedNode.enriched">
<em class="property">property </em><code class="descname">enriched</code><a class="headerlink" href="#node.OneDimensionHansboEnrichedNode.enriched" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">boolean mask indicating which nodes are enriched</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionHansboEnrichedNode.enriched_nodes_compute_new_coordinates">
<em class="property">static </em><code class="descname">enriched_nodes_compute_new_coordinates</code><span class="sig-paren">(</span><em><span class="n">disc</span><span class="p">:</span> <span class="n">xfv.src.discontinuity.discontinuity.Discontinuity</span></em>, <em><span class="n">delta_t</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionHansboEnrichedNode.enriched_nodes_compute_new_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the new nodes coordinates after enrichment
:param disc: current discontinuity
:param delta_t: time step</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionHansboEnrichedNode.enrichment_concerned">
<em class="property">property </em><code class="descname">enrichment_concerned</code><a class="headerlink" href="#node.OneDimensionHansboEnrichedNode.enrichment_concerned" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">boolean mask indicating which nodes are concerned by enrichment</dd>
</dl>
<p>(fonctions de formes enrichies N* non nulles sur leur support)
en 1D : correspond aux noeuds enrichis et les premiers voisins.</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionHansboEnrichedNode.enrichment_not_concerned">
<em class="property">property </em><code class="descname">enrichment_not_concerned</code><a class="headerlink" href="#node.OneDimensionHansboEnrichedNode.enrichment_not_concerned" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">boolean mask indicating which nodes are not concerned by enrichment</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionHansboEnrichedNode.infos">
<code class="descname">infos</code><span class="sig-paren">(</span><em><span class="n">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionHansboEnrichedNode.infos" title="Permalink to this definition">¶</a></dt>
<dd><p>Print information</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionHansboEnrichedNode.initialize_additional_node_dof">
<code class="descname">initialize_additional_node_dof</code><span class="sig-paren">(</span><em><span class="n">disc</span><span class="p">:</span> <span class="n">xfv.src.discontinuity.discontinuity.Discontinuity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionHansboEnrichedNode.initialize_additional_node_dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialialise les ddl enrichis aux noeuds
:param disc: Discontinuity</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionHansboEnrichedNode.reinitialize_kinematics_after_contact">
<code class="descname">reinitialize_kinematics_after_contact</code><span class="sig-paren">(</span><em><span class="n">disc</span><span class="p">:</span> <span class="n">xfv.src.discontinuity.discontinuity.Discontinuity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#node.OneDimensionHansboEnrichedNode.reinitialize_kinematics_after_contact" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the new velocity to the old one to cancel the increment that has lead to contact
:param disc : discontinuity to be considered</p>
</dd></dl>

<dl class="py method">
<dt id="node.OneDimensionHansboEnrichedNode.velocity_field">
<em class="property">property </em><code class="descname">velocity_field</code><a class="headerlink" href="#node.OneDimensionHansboEnrichedNode.velocity_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the true node velocity field</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-output_manager">
<span id="outputs"></span><h2>Outputs<a class="headerlink" href="#module-output_manager" title="Permalink to this headline">¶</a></h2>
<p>Package for output management modules</p>
<dl class="py class">
<dt id="output_manager.OutputDatabase">
<em class="property">class </em><code class="descclassname">output_manager.</code><code class="descname">OutputDatabase</code><span class="sig-paren">(</span><em><span class="n">path_to_hdf5</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputDatabase" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to store simulation fields in an hdf5 database</p>
<dl class="py method">
<dt id="output_manager.OutputDatabase.add_field">
<code class="descname">add_field</code><span class="sig-paren">(</span><em><span class="n">f_name</span></em>, <em><span class="n">values</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputDatabase.add_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a dataset corresponding to field_name and storing the values.
All extra keywords arguments are stored as attributes of the dataset</p>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputDatabase.add_time">
<code class="descname">add_time</code><span class="sig-paren">(</span><em><span class="n">time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputDatabase.add_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an hdf5 group containing all fields for the current time</p>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputDatabase.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputDatabase.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the database</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="output_manager.OutputManager">
<em class="property">class </em><code class="descclassname">output_manager.</code><code class="descname">OutputManager</code><a class="headerlink" href="#output_manager.OutputManager" title="Permalink to this definition">¶</a></dt>
<dd><p>The manager of all outputs</p>
<dl class="py method">
<dt id="output_manager.OutputManager.finalize">
<code class="descname">finalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputManager.finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Close all the database</p>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputManager.get_value_of_field">
<code class="descname">get_value_of_field</code><span class="sig-paren">(</span><em><span class="n">field</span><span class="p">:</span> <span class="n">xfv.src.output_manager.outputmanager.Field</span></em>, <em><span class="n">owner</span></em><span class="sig-paren">)</span> &#x2192; numpy.array<a class="headerlink" href="#output_manager.OutputManager.get_value_of_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the np.array associated to the field following all the attribute names list</p>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputManager.register_all_fields">
<code class="descname">register_all_fields</code><span class="sig-paren">(</span><em><span class="n">enrichment_registration</span></em>, <em><span class="n">cells</span></em>, <em><span class="n">nodes</span></em>, <em><span class="n">database_id</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputManager.register_all_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Add all fields to the manager.
:param enrichment_registration : bool to control if the enriched fields should be registered
:param cells: cells from which fields must be printed
:param nodes: nodes from which fields must be printed
:param database_id: identifier of the database</p>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputManager.register_database_iteration_ctrl">
<code class="descname">register_database_iteration_ctrl</code><span class="sig-paren">(</span><em><span class="n">database_name</span></em>, <em><span class="n">database_obj</span></em>, <em><span class="n">delta_it</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputManager.register_database_iteration_ctrl" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a database to the manager. The database will be updated every delta_it iterations</p>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputManager.register_database_time_ctrl">
<code class="descname">register_database_time_ctrl</code><span class="sig-paren">(</span><em><span class="n">database_name</span></em>, <em><span class="n">database_obj</span></em>, <em><span class="n">delta_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputManager.register_database_time_ctrl" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a database to the manager. The database will be updated every deltat_t seconds</p>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputManager.register_field">
<code class="descname">register_field</code><span class="sig-paren">(</span><em><span class="n">field_name</span></em>, <em><span class="n">field_support</span></em>, <em><span class="n">field_attr_name</span></em>, <em><span class="n">indexes</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">database_names</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputManager.register_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a field to the manager. Each field will be stored in every database in arguments
if specified else in every database registered</p>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputManager.update">
<code class="descname">update</code><span class="sig-paren">(</span><em><span class="n">time</span></em>, <em><span class="n">iteration</span></em>, <em><span class="n">eps</span></em>, <em><span class="n">discontinuity_list</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputManager.update" title="Permalink to this definition">¶</a></dt>
<dd><p>If the current time given in argument is above the time of next output then
the manager asks each of its database to save fields. It’s the same for
a current iteration above the iteration of next output</p>
<p>Additional_dof_fields are created when a new discontinuity is created.
Need to treat them in a different way from classical fields.
Based on this remark, additional_dof_fields have standard name “Additional…”
Differentiation is made with test startswith(Additional)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="output_manager.OutputTimeControler">
<em class="property">class </em><code class="descclassname">output_manager.</code><code class="descname">OutputTimeControler</code><span class="sig-paren">(</span><em><span class="n">identifier</span></em>, <em><span class="n">time_period</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">iteration_period</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputTimeControler" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the time or iteration of outputs</p>
<dl class="py method">
<dt id="output_manager.OutputTimeControler.db_has_to_be_updated">
<code class="descname">db_has_to_be_updated</code><span class="sig-paren">(</span><em><span class="n">time</span></em>, <em><span class="n">iteration</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputTimeControler.db_has_to_be_updated" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the iteration or time requires to write fields in the database
and update the next output time or iteration</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="output_manager.OutputDatabaseExploit">
<em class="property">class </em><code class="descclassname">output_manager.</code><code class="descname">OutputDatabaseExploit</code><span class="sig-paren">(</span><em><span class="n">path_to_db</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputDatabaseExploit" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for exploiting the output stored in Hdf5 database</p>
<dl class="py method">
<dt id="output_manager.OutputDatabaseExploit.extract_discontinuity_opening">
<code class="descname">extract_discontinuity_opening</code><span class="sig-paren">(</span><em><span class="n">time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputDatabaseExploit.extract_discontinuity_opening" title="Permalink to this definition">¶</a></dt>
<dd><p>Read database to extract the discontinuity opening, cohesive force and a bool to
filter results
:param time : time which to extract data at</p>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputDatabaseExploit.extract_field_at_time">
<code class="descname">extract_field_at_time</code><span class="sig-paren">(</span><em><span class="n">field_name</span></em>, <em><span class="n">time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputDatabaseExploit.extract_field_at_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of the specified field at time time in a numpy array</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first simple">
<li><strong>field_name</strong> – name of the field to be extracted</li>
<li><strong>time</strong> – time at which the field has to be extracted</li>
</ul>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first last">the values of the field at time time</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputDatabaseExploit.extract_fields_for_cohesive_zone_model">
<code class="descname">extract_fields_for_cohesive_zone_model</code><span class="sig-paren">(</span><em><span class="n">indice_maille_rompue</span></em>, <em><span class="n">time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputDatabaseExploit.extract_fields_for_cohesive_zone_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Read database to extract the discontinuity opening, cohesive force and a bool to
filter results
:param indice_maille_rompue : maille d’interet pour la zone cohesive
:param time : time which to extract data at</p>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputDatabaseExploit.extract_true_field_at_time">
<code class="descname">extract_true_field_at_time</code><span class="sig-paren">(</span><em><span class="n">field_type</span></em>, <em><span class="n">time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputDatabaseExploit.extract_true_field_at_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of the true field at time time in a numpy array</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first simple">
<li><strong>field_type</strong> – type of the true field (“Pressure”, “Density” …)</li>
<li><strong>time</strong> – time at which the field has to be extracted</li>
</ul>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first last">the values of the true field at time time</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputDatabaseExploit.get_cells_coordinate">
<code class="descname">get_cells_coordinate</code><span class="sig-paren">(</span><em><span class="n">time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputDatabaseExploit.get_cells_coordinate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cells center coordinate at time time
:param time: time at which the cells coordinates are computed
:return: the cells center coordinates</p>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputDatabaseExploit.get_cells_true_size_at_time">
<code class="descname">get_cells_true_size_at_time</code><span class="sig-paren">(</span><em><span class="n">time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputDatabaseExploit.get_cells_true_size_at_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cells true sizes at time time</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>time</strong> – time at which the cells sizes are computed</dd>
<dt class="field-name">Returns</dt><dd class="field-body">the cells true sizes</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputDatabaseExploit.get_nodes_coordinates">
<code class="descname">get_nodes_coordinates</code><span class="sig-paren">(</span><em><span class="n">time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.OutputDatabaseExploit.get_nodes_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract nodes coordinates from database</p>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputDatabaseExploit.nb_saved_times">
<em class="property">property </em><code class="descname">nb_saved_times</code><a class="headerlink" href="#output_manager.OutputDatabaseExploit.nb_saved_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of time step that have been saved</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">the number of time step that have been saved</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputDatabaseExploit.saved_fields">
<em class="property">property </em><code class="descname">saved_fields</code><a class="headerlink" href="#output_manager.OutputDatabaseExploit.saved_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the different fields stored in the database</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">the different fields stored in the database</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputDatabaseExploit.saved_fields_type">
<em class="property">property </em><code class="descname">saved_fields_type</code><a class="headerlink" href="#output_manager.OutputDatabaseExploit.saved_fields_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the different fields type stored in the database</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">the different fields type stored in the database</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="output_manager.OutputDatabaseExploit.saved_times">
<em class="property">property </em><code class="descname">saved_times</code><a class="headerlink" href="#output_manager.OutputDatabaseExploit.saved_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of saved times</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Returns</dt><dd class="field-body">the list of saved times</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="output_manager.build_node_true_field">
<code class="descclassname">output_manager.</code><code class="descname">build_node_true_field</code><span class="sig-paren">(</span><em><span class="n">classical_field</span></em>, <em><span class="n">enrichment_type</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.build_node_true_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the node true field based on the node status</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first simple">
<li><strong>classical_field</strong> – field of classical values</li>
<li><strong>enriched_field</strong> – field of enriched values</li>
<li><strong>node_status</strong> – boolean mask where True indicates an enriched item</li>
<li><strong>enrichment_type</strong> – type of enrichment</li>
</ul>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first last">the node true field</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="output_manager.build_cell_true_field">
<code class="descclassname">output_manager.</code><code class="descname">build_cell_true_field</code><span class="sig-paren">(</span><em><span class="n">classical_field</span></em>, <em><span class="n">enriched_field</span></em>, <em><span class="n">enrichment_type</span></em><span class="sig-paren">)</span><a class="headerlink" href="#output_manager.build_cell_true_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the cell true field based on the cell status</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first last simple">
<li><strong>classical_field</strong> – field of classical values</li>
<li><strong>enriched_field</strong> – field of enriched values</li>
<li><strong>enrichment_type</strong> – type of enrichment. Moes ou Hansbo (utile pour reconstruction)</li>
</ul>
</dd>
</dl>
<p>:return the cell true field</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">build_cell_true_field</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[1.0, 1.5, 2.5, 1.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">build_cell_true_field</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[0.75, 1.25, 2.0, 1.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mf">10.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">build_cell_true_field</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[1.0, 0.0, -4.0, 2.0, 3.0, -9.0, -5.0, 10.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mf">9.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">build_cell_true_field</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[-3.0, 4.0, 0.0, -2.0, 4.0, -3.0, -5.0, 9.0]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-plasticitycriterion">
<span id="plasticity-criterion"></span><h2>Plasticity criterion<a class="headerlink" href="#module-plasticitycriterion" title="Permalink to this headline">¶</a></h2>
<p>Package for plasticity criterion modules</p>
<dl class="py class">
<dt id="plasticitycriterion.PlasticityCriterion">
<em class="property">class </em><code class="descclassname">plasticitycriterion.</code><code class="descname">PlasticityCriterion</code><a class="headerlink" href="#plasticitycriterion.PlasticityCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base class for plasticity criteria</p>
<dl class="py method">
<dt id="plasticitycriterion.PlasticityCriterion.check_criterion">
<em class="property">abstract static </em><code class="descname">check_criterion</code><span class="sig-paren">(</span><em><span class="n">cells</span></em><span class="sig-paren">)</span><a class="headerlink" href="#plasticitycriterion.PlasticityCriterion.check_criterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the plasticity criterion on the cells in arguments</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>cells</strong> – cells on which to check the criterion</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="plasticitycriterion.PlasticityCriterion.check_criterion_on_right_part_cells">
<em class="property">abstract static </em><code class="descname">check_criterion_on_right_part_cells</code><span class="sig-paren">(</span><em><span class="n">cells</span></em><span class="sig-paren">)</span><a class="headerlink" href="#plasticitycriterion.PlasticityCriterion.check_criterion_on_right_part_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the plasticity criterion on the discontinuity in arguments</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>cells</strong> – cells on which to check the criterion</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="plasticitycriterion.VonMisesCriterion">
<em class="property">class </em><code class="descclassname">plasticitycriterion.</code><code class="descname">VonMisesCriterion</code><a class="headerlink" href="#plasticitycriterion.VonMisesCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>A plasticity criterion based on Von Mises model</p>
<dl class="py method">
<dt id="plasticitycriterion.VonMisesCriterion.check_criterion">
<code class="descname">check_criterion</code><span class="sig-paren">(</span><em><span class="n">cells</span></em><span class="sig-paren">)</span><a class="headerlink" href="#plasticitycriterion.VonMisesCriterion.check_criterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mask of the cells where the VonMises plasticity criterion is verified</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>cells</strong> – cells on which to check the criterion</dd>
<dt class="field-name">Returns</dt><dd class="field-body">the mask of the cells where the VonMises plasticity criterion is verified</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="plasticitycriterion.VonMisesCriterion.check_criterion_on_right_part_cells">
<em class="property">static </em><code class="descname">check_criterion_on_right_part_cells</code><span class="sig-paren">(</span><em><span class="n">cells</span></em><span class="sig-paren">)</span><a class="headerlink" href="#plasticitycriterion.VonMisesCriterion.check_criterion_on_right_part_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mask of the cells where the VonMises plasticity criterion is verified</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>cells</strong> – cells on which to check the criterion</dd>
<dt class="field-name">Returns</dt><dd class="field-body">the mask of the cells where the VonMises plasticity criterion is verified</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-rheology">
<span id="rheology"></span><h2>Rheology<a class="headerlink" href="#module-rheology" title="Permalink to this headline">¶</a></h2>
<p>Package for rheology modules</p>
<dl class="py class">
<dt id="rheology.ShearModulus">
<em class="property">class </em><code class="descclassname">rheology.</code><code class="descname">ShearModulus</code><span class="sig-paren">(</span><em><span class="n">initial_value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rheology.ShearModulus" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract class for the shear modulus computation</p>
<dl class="py method">
<dt id="rheology.ShearModulus.compute">
<em class="property">abstract </em><code class="descname">compute</code><span class="sig-paren">(</span><em><span class="n">density</span><span class="p">:</span> <span class="n">numpy.array</span></em><span class="sig-paren">)</span> &#x2192; numpy.array<a class="headerlink" href="#rheology.ShearModulus.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the new value of shear modulus</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="rheology.ConstantShearModulus">
<em class="property">class </em><code class="descclassname">rheology.</code><code class="descname">ConstantShearModulus</code><span class="sig-paren">(</span><em><span class="n">init_value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rheology.ConstantShearModulus" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for constant shear modulus</p>
<dl class="py method">
<dt id="rheology.ConstantShearModulus.compute">
<code class="descname">compute</code><span class="sig-paren">(</span><em><span class="n">density</span><span class="p">:</span> <span class="n">numpy.array</span></em><span class="sig-paren">)</span> &#x2192; numpy.array<a class="headerlink" href="#rheology.ConstantShearModulus.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the shear modulus =&gt; returns constant value of shear modulus</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="rheology.YieldStress">
<em class="property">class </em><code class="descclassname">rheology.</code><code class="descname">YieldStress</code><span class="sig-paren">(</span><em><span class="n">initial_value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rheology.YieldStress" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface for yield stress computation</p>
<dl class="py method">
<dt id="rheology.YieldStress.compute">
<em class="property">abstract </em><code class="descname">compute</code><span class="sig-paren">(</span><em><span class="n">density</span><span class="p">:</span> <span class="n">numpy.array</span></em><span class="sig-paren">)</span> &#x2192; numpy.array<a class="headerlink" href="#rheology.YieldStress.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the new value of shear modulus</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="rheology.ConstantYieldStress">
<em class="property">class </em><code class="descclassname">rheology.</code><code class="descname">ConstantYieldStress</code><span class="sig-paren">(</span><em><span class="n">init_value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rheology.ConstantYieldStress" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for constant yield stress calculation</p>
<dl class="py method">
<dt id="rheology.ConstantYieldStress.compute">
<code class="descname">compute</code><span class="sig-paren">(</span><em><span class="n">density</span><span class="p">:</span> <span class="n">numpy.array</span></em><span class="sig-paren">)</span> &#x2192; numpy.array<a class="headerlink" href="#rheology.ConstantYieldStress.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value of the yield stress
:return: float</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-rupturecriterion">
<span id="rupture-criterion"></span><h2>Rupture criterion<a class="headerlink" href="#module-rupturecriterion" title="Permalink to this headline">¶</a></h2>
<p>Package for rupture criterion modules</p>
<dl class="py class">
<dt id="rupturecriterion.RuptureCriterion">
<em class="property">class </em><code class="descclassname">rupturecriterion.</code><code class="descname">RuptureCriterion</code><a class="headerlink" href="#rupturecriterion.RuptureCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base class for rupture criteria</p>
<dl class="py method">
<dt id="rupturecriterion.RuptureCriterion.check_criterion">
<em class="property">abstract </em><code class="descname">check_criterion</code><span class="sig-paren">(</span><em><span class="n">cells</span></em>, <em><span class="o">*</span><span class="n">args</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rupturecriterion.RuptureCriterion.check_criterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Check of the rupture criterion on the cells in arguments
:param cells: cells on which to check the criterion</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="rupturecriterion.HalfRodComparisonCriterion">
<em class="property">class </em><code class="descclassname">rupturecriterion.</code><code class="descname">HalfRodComparisonCriterion</code><span class="sig-paren">(</span><em><span class="n">ruptured_cell_index</span><span class="o">=</span><span class="default_value">500</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rupturecriterion.HalfRodComparisonCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>A not physical rupture criterion to validate XFEM by comparing
results to other results obtained without XFEM on a half rod</p>
<dl class="py method">
<dt id="rupturecriterion.HalfRodComparisonCriterion.check_criterion">
<code class="descname">check_criterion</code><span class="sig-paren">(</span><em><span class="n">cells</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rupturecriterion.HalfRodComparisonCriterion.check_criterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mask of the cells where only the ruptured_cell_index is set to True</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>cells</strong> – cells on which to check criterion</dd>
<dt class="field-name">Returns</dt><dd class="field-body">mask of the cells where only the ruptured_cell_index is set to True</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="rupturecriterion.DamageCriterion">
<em class="property">class </em><code class="descclassname">rupturecriterion.</code><code class="descname">DamageCriterion</code><span class="sig-paren">(</span><em><span class="n">d_limite</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rupturecriterion.DamageCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>A rupture criterion based on damage value</p>
<dl class="py method">
<dt id="rupturecriterion.DamageCriterion.check_criterion">
<code class="descname">check_criterion</code><span class="sig-paren">(</span><em><span class="n">cells</span></em>, <em><span class="o">*</span><span class="n">args</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rupturecriterion.DamageCriterion.check_criterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mask of the cells where pressure is below the minimum pressure</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>cells</strong> – cells on which to check the criterion</dd>
<dt class="field-name">Returns</dt><dd class="field-body">the mask of the cells where pressure is below the minimum pressure</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="rupturecriterion.MinimumPressureCriterion">
<em class="property">class </em><code class="descclassname">rupturecriterion.</code><code class="descname">MinimumPressureCriterion</code><span class="sig-paren">(</span><em><span class="n">pmin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rupturecriterion.MinimumPressureCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>A rupture criterion based on minimal pressure</p>
<dl class="py method">
<dt id="rupturecriterion.MinimumPressureCriterion.check_criterion">
<code class="descname">check_criterion</code><span class="sig-paren">(</span><em><span class="n">cells</span></em>, <em><span class="o">*</span><span class="n">args</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rupturecriterion.MinimumPressureCriterion.check_criterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mask of the cells where pressure is below the minimum pressure
:param cells: cells on which to check the criterion
:return: the mask of the cells where pressure is below the minimum pressure</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="rupturecriterion.MaximalStressCriterion">
<em class="property">class </em><code class="descclassname">rupturecriterion.</code><code class="descname">MaximalStressCriterion</code><span class="sig-paren">(</span><em><span class="n">sigma_max</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rupturecriterion.MaximalStressCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>A rupture criterion based on minimal pressure</p>
<dl class="py method">
<dt id="rupturecriterion.MaximalStressCriterion.check_criterion">
<code class="descname">check_criterion</code><span class="sig-paren">(</span><em><span class="n">cells</span></em>, <em><span class="o">*</span><span class="n">args</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rupturecriterion.MaximalStressCriterion.check_criterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mask of the cells where pressure is below the minimum pressure</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>cells</strong> – cells on which to check the criterion</dd>
<dt class="field-name">Returns</dt><dd class="field-body">the mask of the cells where pressure is below the minimum pressure</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-rupturetreatment">
<span id="rupture-treatments"></span><h2>Rupture treatments<a class="headerlink" href="#module-rupturetreatment" title="Permalink to this headline">¶</a></h2>
<p>Package for failure treatment modules</p>
<dl class="py class">
<dt id="rupturetreatment.RuptureTreatment">
<em class="property">class </em><code class="descclassname">rupturetreatment.</code><code class="descname">RuptureTreatment</code><a class="headerlink" href="#rupturetreatment.RuptureTreatment" title="Permalink to this definition">¶</a></dt>
<dd><p>An interface for rupture treatments</p>
<dl class="py method">
<dt id="rupturetreatment.RuptureTreatment.apply_treatment">
<em class="property">abstract </em><code class="descname">apply_treatment</code><span class="sig-paren">(</span><em><span class="n">cells</span></em>, <em><span class="n">ruptured_cells</span></em>, <em><span class="o">*</span><span class="n">args</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rupturetreatment.RuptureTreatment.apply_treatment" title="Permalink to this definition">¶</a></dt>
<dd><p>Application of the treatment on the ruptured cells</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first last simple">
<li><strong>cells</strong> – array of all cells</li>
<li><strong>ruptured_cells</strong> – boolean array marking the ruptured cells</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="rupturetreatment.ImposedPressure">
<em class="property">class </em><code class="descclassname">rupturetreatment.</code><code class="descname">ImposedPressure</code><span class="sig-paren">(</span><em><span class="n">pressure</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rupturetreatment.ImposedPressure" title="Permalink to this definition">¶</a></dt>
<dd><p>A treatment of rupture by imposing pressure</p>
<dl class="py method">
<dt id="rupturetreatment.ImposedPressure.apply_treatment">
<code class="descname">apply_treatment</code><span class="sig-paren">(</span><em><span class="n">cells</span></em>, <em><span class="n">ruptured_cells</span></em>, <em><span class="o">*</span><span class="n">args</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rupturetreatment.ImposedPressure.apply_treatment" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the rupture treatment by imposing the pressure on the ruptured cells</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first last simple">
<li><strong>cells</strong> – array of all cells</li>
<li><strong>ruptured_cells</strong> – boolean array marking the ruptured cells</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="rupturetreatment.EnrichElement">
<em class="property">class </em><code class="descclassname">rupturetreatment.</code><code class="descname">EnrichElement</code><span class="sig-paren">(</span><em><span class="n">position_rupture</span><span class="p">:</span> <span class="n">float</span></em>, <em><span class="n">lump_matrix</span><span class="p">:</span> <span class="n">xfv.src.data.enriched_mass_matrix_props.EnrichedMassMatrixProps</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rupturetreatment.EnrichElement" title="Permalink to this definition">¶</a></dt>
<dd><p>A treatment that enrich one of the ruptured cells</p>
<dl class="py method">
<dt id="rupturetreatment.EnrichElement.apply_treatment">
<code class="descname">apply_treatment</code><span class="sig-paren">(</span><em><span class="n">cells</span></em>, <em><span class="n">ruptured_cells</span></em>, <em><span class="n">nodes</span></em>, <em><span class="n">topology</span></em>, <em><span class="n">time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rupturetreatment.EnrichElement.apply_treatment" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the rupture treatment by enriching one of the cells that is marked as ruptured cells
:param cells: array of all cells
:param ruptured_cells: boolean array marking the ruptured cells
:param nodes: array of all nodes
:param topology: topology of the problem</p>
</dd></dl>

<dl class="py method">
<dt id="rupturetreatment.EnrichElement.initialize_cracked_cell_size">
<code class="descname">initialize_cracked_cell_size</code><span class="sig-paren">(</span><em><span class="n">cells</span></em>, <em><span class="n">cell_tb_enr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#rupturetreatment.EnrichElement.initialize_cracked_cell_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the size of the each part of the newly enriched cell
:param cells: cell collection
:param cell_tb_enr: id if the cell to be enriched
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="rupturetreatment.EnrichElement.lump_style">
<em class="property">property </em><code class="descname">lump_style</code><a class="headerlink" href="#rupturetreatment.EnrichElement.lump_style" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the mass matrix lumping to be applied</p>
</dd></dl>

<dl class="py method">
<dt id="rupturetreatment.EnrichElement.position_rupture">
<em class="property">property </em><code class="descname">position_rupture</code><a class="headerlink" href="#rupturetreatment.EnrichElement.position_rupture" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor on the relative position of discontinuity inside the enriched cell</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-solver">
<span id="solver"></span><h2>Solver<a class="headerlink" href="#module-solver" title="Permalink to this headline">¶</a></h2>
<p>Package for solver modules</p>
<dl class="py class">
<dt id="solver.NewtonRaphsonBase">
<em class="property">class </em><code class="descclassname">solver.</code><code class="descname">NewtonRaphsonBase</code><span class="sig-paren">(</span><em><span class="n">function_to_vanish</span></em>, <em><span class="n">nb_iterations_max</span></em>, <em><span class="n">increment_method</span></em><span class="sig-paren">)</span><a class="headerlink" href="#solver.NewtonRaphsonBase" title="Permalink to this definition">¶</a></dt>
<dd><p>This a base class for 1D non linear Newton-Raphson solver</p>
<dl class="py method">
<dt id="solver.NewtonRaphsonBase.compute_solution">
<em class="property">abstract </em><code class="descname">compute_solution</code><span class="sig-paren">(</span><em><span class="n">init_variable</span></em><span class="sig-paren">)</span><a class="headerlink" href="#solver.NewtonRaphsonBase.compute_solution" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the solution</p>
</dd></dl>

<dl class="py method">
<dt id="solver.NewtonRaphsonBase.function">
<em class="property">property </em><code class="descname">function</code><a class="headerlink" href="#solver.NewtonRaphsonBase.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the function to vanish</p>
</dd></dl>

<dl class="py method">
<dt id="solver.NewtonRaphsonBase.nb_iterations_max">
<em class="property">property </em><code class="descname">nb_iterations_max</code><a class="headerlink" href="#solver.NewtonRaphsonBase.nb_iterations_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum iteration number</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="solver.NewtonRaphson">
<em class="property">class </em><code class="descclassname">solver.</code><code class="descname">NewtonRaphson</code><span class="sig-paren">(</span><em><span class="n">function_to_vanish</span></em><span class="sig-paren">)</span><a class="headerlink" href="#solver.NewtonRaphson" title="Permalink to this definition">¶</a></dt>
<dd><p>This class implements a Newton Raphson type non linear solver</p>
<dl class="py method">
<dt id="solver.NewtonRaphson.compute_solution">
<code class="descname">compute_solution</code><span class="sig-paren">(</span><em><span class="n">init_variable</span></em><span class="sig-paren">)</span><a class="headerlink" href="#solver.NewtonRaphson.compute_solution" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the solution through Newton-Raphson algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="solver.NewtonRaphson.set_increment_method">
<code class="descname">set_increment_method</code><span class="sig-paren">(</span><em><span class="n">increment_method_obj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#solver.NewtonRaphson.set_increment_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow a change of incrementation method</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="solver.ClassicalNewtonRaphsonIncrement">
<em class="property">class </em><code class="descclassname">solver.</code><code class="descname">ClassicalNewtonRaphsonIncrement</code><a class="headerlink" href="#solver.ClassicalNewtonRaphsonIncrement" title="Permalink to this definition">¶</a></dt>
<dd><p>Classe définissant un incrément classique de l’algorithme de Newton-Raphson</p>
<dl class="py method">
<dt id="solver.ClassicalNewtonRaphsonIncrement.computeIncrement">
<code class="descname">computeIncrement</code><span class="sig-paren">(</span><em><span class="n">function_value</span></em>, <em><span class="n">derivative_function_value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#solver.ClassicalNewtonRaphsonIncrement.computeIncrement" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment computation</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-utilities">
<span id="utilities"></span><h2>Utilities<a class="headerlink" href="#module-utilities" title="Permalink to this headline">¶</a></h2>
<p>Package for utilities modules</p>
<dl class="py function">
<dt id="utilities.timeit_file">
<code class="descclassname">utilities.</code><code class="descname">timeit_file</code><span class="sig-paren">(</span><em><span class="n">filename</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#utilities.timeit_file" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator allowing to write in the file, the real and cpu execution
times of the decorated function</p>
<p>&#64;param
filename : name of the output file</p>
</dd></dl>

<dl class="py function">
<dt id="utilities.compute_second_invariant">
<code class="descclassname">utilities.</code><code class="descname">compute_second_invariant</code><span class="sig-paren">(</span><em><span class="n">dev_stress</span><span class="p">:</span> <span class="n">numpy.array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#utilities.compute_second_invariant" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the square of the second invariant of stress tensor
J2 = sqrt(3/2 S:S) where S is the deviatoric part of stress tensor
:param stress : deviatoric stress tensor</p>
</dd></dl>

<dl class="py function">
<dt id="utilities.compute_trace">
<code class="descclassname">utilities.</code><code class="descname">compute_trace</code><span class="sig-paren">(</span><em><span class="n">stress</span><span class="p">:</span> <span class="n">numpy.array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#utilities.compute_trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute trace(sigma)
:param stress : stress tensor
:return : trace(sigma)</p>
</dd></dl>

<dl class="py function">
<dt id="utilities.captured_output">
<code class="descclassname">utilities.</code><code class="descname">captured_output</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#utilities.captured_output" title="Permalink to this definition">¶</a></dt>
<dd><p>A context manager for capturing output (by Jonathon Reinhart)</p>
</dd></dl>

<dl class="py class">
<dt id="utilities.Singleton">
<em class="property">class </em><code class="descclassname">utilities.</code><code class="descname">Singleton</code><span class="sig-paren">(</span><em><span class="o">*</span><span class="n">args</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#utilities.Singleton" title="Permalink to this definition">¶</a></dt>
<dd><p>A metaclass implementing singleton pattern</p>
<dl class="py method">
<dt id="utilities.Singleton.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#utilities.Singleton.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the singleton
:return:</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="index-and-tables">
<h1>Index and tables<a class="headerlink" href="#index-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


          </div>
            
  <div class="footer-relations">
    
      <div class="pull-left">
        <a class="btn btn-default" href="organisation.html" title="previous chapter (use the left arrow)">Code organisation</a>
      </div>
    
      <div class="pull-right">
        <a class="btn btn-default" href="installation.html" title="next chapter (use the right arrow)">Installation</a>
      </div>
    </div>
    <div class="clearer"></div>
  
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installation"
             >next</a> |</li>
        <li class="right" >
          <a href="organisation.html" title="Code organisation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">XVOF  documentation</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 2020, M. Gorecki, G. Peillex. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>